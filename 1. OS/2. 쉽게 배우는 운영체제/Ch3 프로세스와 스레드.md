# Chapter3 프로세스와 스레드

[[_TOC_]]

## 1. 프로세스 개요

### 1. 프로세스의 개념

- 프로세스와 프로그램의 차이
  - 프로그램은 저장장치에 저장되어 있는 **정적인 상태**
  - 프로세스는 실행을 위해 메모리에 올라온 **동적인 상태**



### 2. 요리사 모형에 비유

#### 2.1 주문서의 역할

- 주문서는 요리의 전반적인 조리 방법과 요리가 나가는 순서를 결정하는 중요한 자료
- 주문서가 주방에 전달되면 요리사는 주문서에 적힌대로 요리를 하여 손님에게 제공



#### 2.2 일괄 작업 방식의 요리

- 일괄 작업 시스템은 한 번에 하나의 작업만을 처리하므로 테이블이 하나만 있는 것과 다름이 없음
  - 따라서 테이블의 번호가 없음
  - 요리가 제공되는 순서가 단순하고, 손님이 식사하는 동안 쉬는 시간이 생겨 효율이 떨어짐
- 주방에서는 주문이 들어온 순서대로 요리하기 위해 **주문 목록**을 사용하며 **큐**로 처리됨



#### 2.3 시분할 방식의 요리

- 요리사는 1명이라도 시간을 적당히 배분하여 여러 요리를 동시에 만드는 시분할 방식
  - 손님이 식사하는 시간을 충분히 활용하여 여러 테이블에 지체 없이 요리를 제공



- 주문 목록
  - 손님이 주문을 하면 주문서를 주문 목록에 올림
  - 주문 받은 단품 요리 하나를 만든 후 주문 목록의 맨 뒤로 옮기고 다른 주문서를 가져다 단품 요리를 만듬
  - 주문서의 모든 요리가 제공되면 주문서는 주문 목록에서 삭제



#### 2.4 시분할 방식에서의 예상치 못한 상황 처리

- 보조 요리사의 재료 손질이 아직 끝나지 않아 요리사가 기다리는 경우
  - 현명한 요리사라면 주문서를 **대기 목록**으로 옮기고 주문 목록에 있는 다른 주문서를 가져와 요리
    - **대기 목록**은 재료 손질이 끝날 때까지 기다리는 곳
  - 만약, 재료 손질이 끝나면 기존에 하던 요리가 끝난 후 돌아감
    - 즉, **대기 목록**에서 **주문 목록**으로 이동하여 다음 순서를 기다림



- 손님이 볼일이 있어 음식을 천천히 달라고 하거나 식사를 포기한 경우
  - 이와 같이 언제 다시 시작될지 모르는 주문서는 **보류 목록**으로 옮김
    - 손님이 음식을 달라고 하면 **보류 목록**에 있는 주문서를 **주문 목록**으로 보냄
    - 손님이 식사를 중단한다면 주문서를 폐기함
  - 보류 목록의 작업은 언제 다시 시작될지 또는 그만둘지 모르므로 대기 목록의 작업과 구분됨



- 현대의 운영체제는 시분할 방식을 사용하므로 프로세스가 여러 상태를 오가며 실행됨



### 3. 프로그램에서 프로세스로 전환

- **태스크**
  - 컴퓨터 시스템의 작업 단위(프로세스의 다른 말)



- 프로그램에서 프로세스로 전환 과정
  - 운영체제가 프로그램을 메모리의 적당한 위치로 가져옴
  - 동시에 주문서에 해당하는 작업 지시서(프로세스의 제어 블록-PCB)를 만듬
    - 프로세스 제어 블록에는 프로세스를 처리하는 데 필요한 다양한 정보가 담김
      - 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못함
    - 대표적인 정보
      1. **프로세스 구분자**
         - 메모리에는 여러 개의 프로세스가 존재하므로 각 프로세스를 구분하는 구분자(ID)가 필요
      2. **메모리 관련 정보**
         - 프로세스의 메모리  위치 정보와 메모리 보호를 위한 경계 레지스터와 한계 레지스터 정보
           - CPU는 실행하려는 프로세스가 메모리의 어디에 저장되어 있는지 알아야 함
      3. **각종 중간값**
         - 프로세스가 사용했던 중간값이 저장됨
         - 즉, 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장됨
           - 프로세스 중간에 다른 프로세스를 실행했다가 다시 돌아왔을 때, 어디부터 시작할지
  - 프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조로 운영체제 영역에 생성됨
  - 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로제스 제어 블록도 삭제됨



- 정리
  - 프로그램이 프로세스가 된다는 것은 운영체제로부터 프로세스 제어 블록을 얻는다는 것
  - 프로세스: 프로그램 + 프로세스 제어 블록
  - 프로그램: 프로세스 - 프로세스 제어 블록



### 4 프로세스의 상태

- 일괄 작업 시스템에서의 프로세스 상태
  - 생성, 실행, 완료

- 시분할에서는 중간에 다른 프로세스로 CPU를 넘겨주는 경우가 있으므로 더 복잡함



#### 4.1 프로세스의 네 가지 상태

- 프로세스 상태
  - **생성 상태**
    - 프로세스가 메모리에 올려와 실행 준비를 완료한 상태
    - 프로세스를 관리하는 데 필요한 프로세스 제어 블록을 생성
  - **준비 상태**
    - 생성된 프로세스가 CPU를 기다리는 상태
  - **실행 상태**
    - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태(`execute status`)
    - 실행 상태에 들어간 프로세스는 일정 시간 동안 CPU를 사용할 권리를 갖음
      - 주어진 시간에도 못 끝내면 준비 상태로 돌아와 다음 차례를 기다림
  - **완료 상태**
    - 실행 상태의 프로세스가 주어진 시간 동안 작업을 완료 상태로 진입
    - 프로세스 제어 블록이 사라진 상태를 의미



- **CPU 스케줄러**
  - 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 역할
    - 준비 상태에 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달하여 작업이 이뤄지게 함
  - **디스패치**
    - 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 작업



- **타임 슬라이스 | 타임 퀀텀**
  - 프로세스에 배정된 작업 시간을 의미
  - 이 시간이 넘어가면 다시 준비 상태로 돌아감 => **타임 아웃**
  - CPU에서는 일정 시간(타임 슬라이스) 후에 알려달라고 클록에 요청하고, 클록은 인터럽트를 통해 CPU에 알려줌



#### 4.2 프로세스의 다섯 가지 상태

- **대기 상태**가 추가된 이유
  - 기존의 네 가지 상태로도 작업을 수행하는 데 큰 문제는 없음
  - 하지만 인터럽트 시스템에서 프로세스가 입출력을 요구하면, CPU는 입출력 관리자에게 대신 데이터를 가져오게 만드는데, 이 상태에서 프로세스와 CPU는 아무 작업을 하지 않아 효율이 떨어짐



- **대기 상태**
  - 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
  - 즉, 실행 상태에 두지 않고 대기 상태로 옮기는 것
    - CPU 스케줄러는 준비 상태에 있는 다른 프로세스 중 하나를 가져다 실행 상태로 만듬
  - 대기 상태의 프로세스가 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받음
    - 대기 상태가 끝난 뒤 실행 상태로 돌아가는 것이 아닌 준비 상태로 돌아감
    - 이미 실행 중인 프로세스가 있기 때문



- 프로세스 상태
  - **생성 상태**
    - 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당받은 상태
  - **준비 상태**
    - 실행 중인 모든 프로세스가 자기 순서를 기다리는 상태
    - 프로세스 제어 블록은 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리
      - CPU 스케줄러는 준비 상태에서 큐를 몇 개 운영할지, 큐에 있는 어떤 프로세스 제어 블록을 실행 상태로 보낼지 결정
      - CPU 스케줄러가 어떤 프로세스를 선택하는 작업은 `dispatch(PID)` 명령으로 처리
        - PID는 프로세스 구분자
  - **실행 상태**
    - 프로세스가 CPU를 할당받아 실행되는 상태(CPU 개수만큼 존재)
    - 프로세스는 자신에게 주어진 타임 슬라이스 동안만 작업
      - 시간이 넘어가면 `timeout(PID)`가 실행
        - 프로세스 제어 블록을 준비 상태로 옮김
      - 시간 내 완료하면 `exit(PID)`가 실행
      - 입출력을 요구하면 block(PID)가 실행
        - 프로세스 제어 블록을 대기 상태로 옮김
  - **대기 상태**
    - 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태(`wait status`)
    - 프로세스는 입출력 장치별로 마련된 큐에서 기다림
    - 입출력이 완료되면 인터럽트가 발생하고, `wakeup(PID)`가 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾아 준비 상태로 옮김
  - **완료 상태**
    - 프로세스가 종료된 상태
    - 코드와 사용했던 데이터를 메모리에서 삭제하고 프로세스 제어 블록을 폐기
    - 정상적인 종료는 `eixt()`로 처리
    - 만약 오류나 다른 프로세스로 인해 비정상적으로 종료되는 강제 종료(abort)를 만나면 디버깅을 위해 종료 직전의 메모리 상태를 저장장치로 옮기는데 이를 코어 덤프라 함



#### 4.3 휴식 상태와 보류 상태

- **활성 상태**
  - 생성, 준비, 실행, 대기, 완료의 상태



- **휴식 상태**
  - 프로세스가 일시적으로 작업을 쉬고 있는 상태
  - 사용하던 데이터가 메모리에 그대로 있고, 프로세스 제어 블록도 유지되므로 멈춘 지점부터 재시작할 수 있음



- **보류 상태**
  - 프로세스가 메모리에서 잠시 쫓겨난 상태
  - 다음의 경우 `일시 정시 상태`라고  함(대부분 실행을 미루어도 큰 지장이 없는 프로세스)
    - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
    - 프로그램에 오류가 있어서 실행을 미무어야 할 때
    - 바이러스와 같이 악의적인 공격을 하는 프로세스라 판단될 때
    - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫒아내도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
  - 보류 상태에 들어간 프로세스는 메모리 밖으로 쫒겨나 스왑 영역에 보관
    - 스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 곳
    - 보류는 스왑 영역에 있는 상태이고, 휴식은 프로세스가 메모리에 있느나 멈춘 상태
  - 보류는 대기 상태에서 옮겨진 **보류 대기 상태**와 준비 상태에서 옮겨진 **보류 준비 상태**로 구분
    - 각 상태에서 재시작하면 원래의 활성 상태로 들어감
    - 또한 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 준비 상태로 옮겨감



## 2. 프로세스 제어 블록과 문맥 교환

### 1. 프로세스 제어 블록

- 프로세스 제어 블록(PCB | TCB)
  - 프로세스를 실행하는 데 필요한 중요 정보를 보관하는 자료 구조
  - 모든 프로세스가 가지며 생성 시에 만들어져 실행을 완료하면 폐기됨



#### 1.1 프로세스 제어 블록의 구성

- 프로세스 제어 블럭

  | 포인터 | 프로세스 상태 |
  | :----: | :-----------: |

  |    프로세스 구분자     |
  | :--------------------: |
  |  **프로그램 카운터**   |
  | **프로세스 우선순위**  |
  | **각종 레지스터 정보** |
  |  **메모리 관리 정보**  |
  |  **할당된 자원 정보**  |
  |     **계정 정보**      |
  |    **PPID와 CPID**     |
  |     **기타 등등**      |



- **포인터**
  - 프로세스 제어 블록을 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 사용
  - 프로세스 제어 블록의 첫 번째 블록에 저장



- **프로세스 상태**
  - 생성, 준비, 실행, 대기, 보류 준비, 보류 대기 등의 상태를 의미
  - 프로세스 제어 블록의 두 번째 블록에 저장



- **프로그램 구분자**
  - 운영체제 내에 있는 여러 프로세스를 구분하기 위한 구분자를 저장



- **프로그램 카운터**
  - 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터 값을 저장



- **프로세스 우선순위**
  - 프로세스의 중요도를 저장
    - ex) 사용자 프로세스보다 커널 프로세스가 중요도가 높음(사용자 프로세스끼리도 다름)
    - 다양한 우선순위의 프로세스가 대기 상태로 들어오므로 대기 상태의 큐도 우선순위별로 운영됨
    - CPU 스케줄러가 준비 상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때는 프로세스 우선순위를 기준으로 삼음
    - 즉, 높은 우선순위의 프로세스가 더 먼저 더 자주 실행됨



- **각종 레지스터 정보**
  - 프로세스가 실행 중 사용하던 레지스터(누산기, 색인 레지스터 등)와 같은 값이 저장
    - 이전에 실행할 때 사용한 레지스터 값을 보관해야 다음에 실행할 수 있기 때문(레지스터의 중간값을 보관)



- **메모리 관리 정보**
  - 메모리 위치 정보(프로세스가 메모리 어디에 있는지), 경계 레지스터 값과 한계 레지스터 값(메모리 보호를 위해)이 저장
  - 그 외의 세그먼테이션 테이블, 페이지 테이블 등의 정보도 보관



- **할당된 자원 정보**
  - 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
    - ex) 파일이나 사운드카드에 대한 정보를 프로세스 제어 블록에 저장



- **계정 정보**
  - 계정 번호, CPU 할당 시간, CPU 사용 시간 등



- PPID와 CPID
  - 부모 프로세스 구분자, 자식 프로세스 구분자 등



#### 1.2 포인터의 역할

- 대기 상태의 프로세스들
  - 만약 대기 상태의 모든 프로세스를 하나로 모아둔다면, 한 입출력장치의 인터럽트가 들어왔을 때, 모든 프로세스를 찾아야 함
  - 이를 구분하기 위해 대기 상태에는 같은 입출력을 요구한 프로세스들끼리 모아두는데 이때 포인터를 사용
    - 예를 들어 하드디스크 입출력을 기다리는 프로세스 제어 블록은 하드디스크 큐에 삽입



### 2. 문맥 교환

#### 2.1 문맥 교환의 의미

- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
  - 이때 두 프로세스 제어 블록의 내용이 변경됨
    - 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장
    - 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅



#### 2.2 문맥 교환의 절차

- P1과 P2 프로세스의 문맥 교환의 절차
  - 실행 상태에 있는 P1이 자신에게 주어진 시간을 다 사용하여 타임아웃
  - P1의 프로세스 제어 블록에 작업 결과가 저장 후 준비 상태로 감
  - 준비 상태에 있던 P2가 실행 상태로 가고, CPU의 레지스터가 P2 프로세스 제어 블록 값으로 채워지고 작업 수행



- 발생하는 상황
  - 일반적으로는 프로세스가 주어진 시간을 다 사용한 경우 발생
  - 인터럽트가 걸렸을 때도 발생
    - 예를 들어 프로세스가 자신에게 주어진 메모리 공간을 벗어난 경우



## 3. 프로세스 연산

### 1. 프로세스 구조

- 프로세스 구조
  - 프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성
  - **코드 영역**
    - 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 함
    - 작성한 프로그램은 코드 영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리됨
  - **데이터 영역**
    - 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳
    - 데이터는 변하는 값이므로 기본적으로 읽기와 쓰기가 가능
  - **스택 영역**
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
    - 예를 들어 함수를 실행하고 돌아올 위치를 스택 영역에 저장함
    - 스택 영영은 사용자게에는 보이지 않음



### 2. 프로세스 생성과 복사

- 생성과 복사
  - 프로세스를 생성하는 경우(사용자가 프로그램을 실행한 경우)
    - 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록을 생성
    - 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행
  - 실행 중인 프로세스를 복사하는 경우



#### 2.1 fork() 시스템 호출의 개념

- `fork()`
  - 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수(커널에서 제공)
    - 사용하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어짐
    - 처음 프로그램을 실행하는 속도보다 더 빠르게 만들어짐
      - 원래 프로그램은 부모 프로세스가 되고, 새로 생긴 프로세스는 자식 프로세스가 됨
    - 예를 들어 워드 프로세서를 작업을 하다가 하나 더 실행한 경우



#### 2.2 fork() 시스템 호출의 동작 과정

- `fork()`
  - 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 만들어짐
  - 다른 점
    - 프로세스 구분자(PID)가 변경
    - 메모리 관련 정보가 변경(부모와 자식 프로세스가 차지하고 있는 메모리 위치가 다르므로)
    - PPID와 CPID가 변경(만약 자식이 없는 경우 -1로 표시)



#### 2.3 fork() 시스템 호출의 장점

1. **프로세스의 생성 속도가 빠름**
   - 하드디스크로부터 프로그램을 새로 가져오는 것이 아니고 기존 메모리에서 복사하므로 빠름
2. **추가 작업 없이 자원을 상속할 수 있음**
   - 부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 모두 사용 가능함
3. **시스템 관리를 효율적으로 할 수 있음**
   - 부모와 자식 프로세스는 구분자로 연결되어 있기 때문에, 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있음
     - 메모리 영역, 파일, 하드웨어 등을 정리하는 것을 부모가 맡게 되는 것



### 3. 프로세스 전환

- 같은 프로세스가 아니여도 `fork()`로 복사한 뒤, `exec()`로 바꾸는 방식도 존재



#### 3.1 exec() 시스템 호출의 개념

- `exec()`
  - 기존의 프로세스를 새로운 프로세스로 전환하는 함수
  - 프로세스의 구조체를 재활용하기 위함
    - 새로운 프로세스를 만들려면 
      - 프로세스 제어 블록을 생성
      - 메모리의 자리를 확보
      - 또한, 종료 후 메모리 청소를 위해 상위 프로세스와 부모-자식 관계가 필요



#### 3.2 exec() 시스템 호출의 동작 과정

- `exec()`
  - 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿈
  - 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋됨
  - PID, PPID, CPID, 메모리 관련 사항은 변하지 않지만 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋



### 4. 프로세스의 계층 구조

#### 4.1 유닉스의 프로세스 계층 구조

- 유닉스
  - 커널이 처음 메모리에 올라와 부팅이 되면 커널 관련 프로세스를 여러 개 만드는데, 그중 **init 프로세스**는 전체 프로세스의 출발점이 됨
    - 프로세스의 효율적 관리를 위해 init 프로세스를 만든 이후에는 init 프로세스의 자식으로 만듬
    - init의 자식은 login 프로세스, shell 프로세스 등이 존재



#### 4.2 프로세스 계층 구조의 장점

1. **여러 작업의 동시 처리**
   - login 프로세스는 인증을 거쳐 컴퓨터에 접속하는 과정을 처리
     - 이때 동시에 3명이 컴퓨터에 접속한다면 `fork()`로 여러 login 프로세스를 만들어 나누어 줌
   - login은 종료되고 shell 프로세스가 생성
     - 이때 `exec()`로 login 프로세스의 구조를 shell 프로세스로 다시 활용(부모-자식 관계도 유지)
   - shell 프로세스는 사용자가 운영체제에 명령을 내리고 받음
     - 이후 사용자가 명령을 내리면 `fork()`로 shell 프로세스를 만든 후, `exec()` 시스템 호출을 사용하여 해당 프로세스로 바꿔줌
2. **용이한 자원 회수**
   - 자식 프로세스가 사용하던 자원을 부모 프로세스가 회수하면 됨



#### 4.3 고아 프로세스

- 고아 프로세스
  - 만약 부모가 먼저 종료된 경우 자식 프로세스가 종료되지 않거나 종료되어도 사용하던 자원이 그대로 남을 수 있음
    - 프로세스가 종료된 후에도 비정상적으로 남아 있는 프로세스를 **좀비 프로세스**라고 함
  - 따라서 운영체제는 회수 못한 자원을 회수하는 **자원 회수**를 주기적으로 해야 함



## 4. 스레드

### 1. 스레드의 개념

#### 1.1 스레드의 저의

- **스레드**
  - 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위
  - CPU 스케줄러가 CPU에 전달하는 일 하나를 의미
    - 즉, CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드



- **작업의 크기**
  - 처리(job) > 프로세스(task) > 스레드(operation)
  - 여러 개의 스레드가 모여 프로세스를 이루고, 여러 개의 프로세스가 모여 처리가 됨
    - 여러 개의 프로세스를 모아 한꺼번에 처리하는 방법을 일괄 작업(batch job)이라 함



#### 1.2 프로세스와 스레드의 차이

- 연결 강도
  - 개개의 프로세스와 스레드는 서로서로 미치는 영향이 다름
  - **멀티태스크**
    - 서로 독립적인 프로세스(ex - 워드 프로세스와 스풀러의 관계)
      - 즉, 하나를 종료해도 다른 것에 영향 없음
    - 멀티태스크는 데이터를 주고 받을 때 프로세스 간 통신을 이용
  - **멀티스레드**
    - 강하게 연결되어 있는 스레드들이 동시에 작업하는 것
      - 즉, 하나를 종료하면 모두 강제 종료됨
    - 멀티스레드는 변수나 파일 등을 공유하고 전역 변수나 함수 호출 등의 방법으로 스레드 간 통신



#### 1.3 스레드 관련 용어

- **멀티스레드**
  - 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
- **멀티태스킹**
  - 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법(시분할 시스템)
    - 시분할 시스템에서는 운영체제가 CPU에 전달하는 작업은 프로세스가 아니라 스레드
- **멀티프로세싱**
  - CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경(슈퍼스칼라 기법)
- **CPU 멀티스레드**
  - 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법
    - **멀티스레드**: 소프트웨어적으로 프로세스를 작은 단위의 스레드로 분할하여 운영
    - **CPU 멀티스레드**: 하드웨어적으로 하나의 CPU에서 여러 스레드를 동시에 처리하는 병렬 처리 기법



### 2. 멀티스레드의 구조와 예

#### 2.1 멀티스레드의 구조

- `fork()` 시스템 호출의 비효율성
  - C와 같은 초기의 프로그래밍 언어는 순차 실행되므로 여러 개의 작업을 처리하기 불편했기 때문에 `fork()`를 이용함
  - 하지만 프로세스를 복사하면 코드 영역과 데이터 영역의 일부가 메모리에 중복되어 존재하게 됨
    - 부모-자식 관계이지만 서로 독립적인 프로세스이므로 이러한 낭비 요소를 제거할 수 없음
  - **스레드를 통한 멀티태스킹의 낭비를 제거**
    - 데이터를 공유하면서 여러 개의 일을 하나의 프로세스 내에서 하는 것
    - 프로세스는 크게 정적 영역과 동적 영역으로 구분
      - **정적 영역**: 프로세스가 실행하면서 바뀌지 않는 여역
      - **동적 영역**: 스레드가 작업을 하면서 값이 바뀌거나 새로 만들어지거나 사라지는 영역
    - `fork()`를 사용하면 정적 영역이 중복되지만, 멀티스레드는 코드, 파일 등의 자원을 공유하여 효율을 높임
      - 즉, 하나의 프로세스에 여러 개의 스레드를 생성하는 것



### 3. 멀티스레드의 장단점

#### 3.1 멀티스레드의 장점

- **응답성 향상**
  - 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 작업 요구에 빨리 응답할 수 있음
- **자원 공유**
  - 여러 개의 프로세스를 생성하는 것과 달리 멀티스레드는 불필요한 자원의 중복을 막음으로써 시스템 효율이 향상
- **다중 CPU 지원**
  - 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축



#### 3.2 멀티스레드의 단점

- **오류 발생 시 문제**
  - 멀티스레드는 자원을 공유하므로 하나에 문제가 발생하면 전체 프로세스에 영향을 미치게 됨



### 4. 멀티스레드 모델

- **커널 스레드**
  - 커널이 직접 생성하고 관리하는 스레드
- **사용자 스레드**
  - 라이브러리에 의해 구현된 일반적인 스레드
  - 사용자 스레드가 커널 스레드를 이용하려면 시스템 호출로 커널 기능을 이용해야 함



#### 4.1 사용자 스레드

- 사용자 스레드
  - 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법(초기의 스레드 시스템)
  - 사용자 레벨에서 구현하기 때문에 관련 라이브러리를 사용하여 구현하며, 라이브러리는 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현해줌
  - 커널이 하는 일을 라이브러리가 대신 처리하여 여러 스레드를 작동함
  - 사용자 프로세스 내에 여러 개의 스레드가 존재하지만 커널의 스레드 하나와만 연결되므로 **1 to N 모델**
  - **장점**
    - 문맥 교환 없이 필요한 값만 저장했다가 복귀시키므로 속도가 빠름
  - **단점**
    - 하나의 커널 스레드와 연결되므로 커널 스레드가 입출력 작업을 위해 대기 상태가 되면 모든 사용자 스레드가 같이 대기함
    - 한 프로세스의 타임 슬라이스를 여러 스레드가 공유하므로 여러 개의 CPU를 동시에 사용할 수 없음
    - 보안에 취약(커널 레벨에서의 공유 변수를 보호하는 장치가 있으나 이를 라이브러리에서 구현해야 하기 때문)



#### 4.2 커널 스레드

- 커널 스레드
  - 커널이 멀티스레드를 지원하는 방식
  - 하나의 사용자 스레드가 하나의 커널 스레드와 연결되므로 **1 to 1 모델**
  - **장점**
    - 독립적으로 스케줄링 되므로 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 할 수 있음
    - 보안에 강하고 안정적(커널이 제공하는 보호 기능과 같은 모든 기능을 사용할 수 있음)
  - **단점**
    - 문맥 교환을 할 때 오버헤드 때문에 느리게 작동



#### 4.3 멀티레벨 스레드

- 멀티레벨 스레드(하이브리드 스레드)
  - 사용자 스레드와 커널 스레드를 혼합한 방식으로 **M to N**
  - 커널 스레드의 개수 <= 사용자 스레드
  - **장점**
    - 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 할 수 있음
  - **단점**
    - 여전히 커널 스레드를 같이 사용하므로 문맥 교환 시 오버헤드가 있어 사용자 스레드보다 느림
  - 빠르게 움직여야 하는 스레드 => 사용자 스레드, 안정적으로 움직여야 하는 스레드 => 커널 스레드



## 5. [심화학습] 동적 할당 역역과 시스템 호출

### 1. 프로세스의 동적 할당 역역

- 프로세스
  - 코드 영역, 데이터 영역, 스택 영역 이외의 힙 영역도 존재
  - **정적 할당 영역**
    - 포인터를 제외한 변수는 선언할 때 크기가 정해짐 => 코드 영역, 데이터 영역
    - 즉, 실행되기 직전에 위치와 크기가 결정되고 실행 동안 변하지 않는 정적 할당 영역임
  - **동적 할당 영역**
    - 스택 영역과 힙 영역은 프로세스가 실행되는 동안 만들어지는 영역으로 크기가 줄거나 늘어남



#### 1.1 스택 영역

- 함수를 호출하는 코드

  ```c
  int main() {
      int a=1, b=2
      printf("main %d %d\n", a b);
      add(a, b);
      exit(); }
  
  add(int c, int d) {
      mul(c, d)
      printf("add %d\n", c+d); }
  
  mul(int e, int f) {
      printf("mul %d\n", e*f); }
  ```



- 스택은 함수 호출 시 두 가지 작업을 구현하기 위해 사용
  1. 호출된 함수가 종료되면 함수를 호출하기 전 코드로 되돌아와야 하는데 되돌아올 메모리의 주소를 스택에 저장
     - 위 코드에서 `main()`, `add()`, `mul()` 함수를 호출하고 복귀할 때 스택이 사용
  2. 스택은 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용
     - 변수는 **전역 변수**와 **지역 변수**로 나뉨
       - 전역 변수는 프로그램 내에 있는 모든 함수에서 사용  가능하고 지역 변수는 특정 함수에서만 사용 가능
     - 함수에서 사용하는 지역 변수는 함수가 호출될 때만 사용되다가 종료되면 공간을 반환해야 하는데, 지역 변수를 저장할 때 스택이 사용



- 스택
  - 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당 영역
    - 스택의 영역의 크기는 줄어들거나 커지는 동적 영역



#### 1.2 힙 영역

- 힙

  - 동적으로 할당되는 변수 영역

  - 대부분은 선언될 때 크기가 할당되나 실행되는 동안 할당되는 대표적인 경우가 `malloc()` 함수

    ```c
    main() {
        int sarr[50];
        int *darr;
        
        darr = (int*)malloc(sizeof(int)*50);
        free(darr)
    }
    ```

    - 선언부에 sarr은 50개짜리 정수 배열이나 darr은 포인터로서 아직 크기가 정해지지 않음
      - `malloc()`을 만나면 그때야 메모리에 자리를 차지함
      - 즉, 스레드가 `(int*)malloc(sizeof(int)*50);`를 만나면 힙 영역에 정수 50개의 공간을 배정
      - sarr은 데이터 영역, darr은 힙 영역에 생기게 되는 것
        - sarr은 프로세스 종료까지 메모리를 차지함
        - darr은 `malloc()` 함수로 메모리를 할당받았다가 필요 없어지면 `free()` 함수로 메모리 영역을 반환함

  - 힙 영역 활용

    - 크기를 정할 수 없을 때 사용
      - 워드프로세스의 문서를 편집하는 공간, 프로세스 제어 블록의 배열 크기 등은 미리 크기를 알 수 없음
    - 잠시 메모리가 필요한 경우
      - 데이터 영역은 처음부터 끝까지 공간을 차지하며 존재하게 됨



### 2. exit()와 wait() 시스템 호출

#### 2.1 exit() 시스템 호출

- 종료를 선언
  - `exit()`, `return()`문을 사용하는 것은 자식 프로세스가 끝났음을 부모에게 알려주기 위함
    - `exit()` 함수는 전달하는 인자에 따라 자식 프로세스가 어떤 상태로 종료되었는지 알 수 있음
      - 0 => 정상 종료, 1 => 비정상 종료



#### 2.2 wait() 시스템 호출

- `wait()`
  - 고아 프로세스가 생기는 것을 방지하기 위해 사용
  - 즉, 부모 프로세스에서 자식 프로세스가 종료되기까지 기다리게 만듬
  - 부모 프로세스와 자식 프로세스 간 동기화에도 사용됨
