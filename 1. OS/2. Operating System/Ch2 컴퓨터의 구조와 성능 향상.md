# Chapter2 컴퓨터의 구조와 성능 향상

[[_TOC_]]

## 1. 컴퓨터의 기본 구성

### 1. 하드웨어의 구성

- 컴퓨터
  - CPU(중앙처리장치), 메인메모리, 입력장치, 출력장치, 저장장치로 구성
    - 여기서 CPU와 메인메모리는 필수 장치, 나머지는 주변장치로 구분됨



#### 1.1 CPU와 메모리

- **CPU**
  - 명령어를 해석하여 실행하는 장치



- **메모리**
  - 작업에 필요한 프로그램과 데이터를 저장하는 장소
  - 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분
    - 메인메모리는 전력이 끊기면 데이터를 잃어버리는 **휘발성**



#### 1.2 입출력 장치

- **입력장치**
  - 외부의 데이터를 컴퓨터에 입력하는 장치
  - 키보드, 마우스, 스캐너 등
    - 초기의 컴퓨터는 천공카드 | 모바일은 터치 스크린



- **출력장치**
  - 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치
  - 프린터(잉크젯, 레이저, 3D 등), 모니터(그래픽 카드와 연결), 스피커(사운드카드와 연결)



#### 1.3 저장장치

- **저장장치**
  - 메모리는 전자의 이동으로 데이터를 처리하지만, 하드디스크 등은 구동 장치가 있는 기계이므로 느림
  - 전원의 온오프와 관계 없이 데이터를 저장하는 **비휘발성**이고, 가격이 저렴함
  - 종류
    - 자성을 이용
      - 카세트테이프, 플로피디스크, 하드디스크
    - 레이저를 이용
      - CD, DVD, 블루레이디스크
    - 메모리를 이용
      - USB 드라이버, SD 카드, CF 카드, SSD



#### 1.4 메인보드

- **버스**
  - 일정한 규칙에 따라 각 장치에 데이터를 전송하는 역할
    - 각 장치를 연결하는 선의 집합이자 데이터가 지나다니는 통로
  - 컴퓨터의 다양한 부품은 버스로 연결



- **메인보드**
  - CPU와 메모리 등 다양한 부품을 연결하는 커다란 판
    - 버스(가는 선)가 복잡하게 얽혀 있으며 전력이 공급되면 버스로 연결된 부품이 작동함



### 2. 폰노이만 구조

- **폰노이만 구조**
  - 오늘날 대부분의 컴퓨터 구조로 CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조를 의미
    - 기존에는 전선을 연결하여 회로를 구성하는 **하드와이어링** 형태
  - 가장 중요한 특징은 **모든 프로그램이 메모리에 올라와야 실행할 수 있음**



### 3. 요리사 모형

- 요리사 모형
  - 운영체제의 여러 가지 현상에 대해 이해를 돕기 위한 모형
  - 요리사는 CPU, 도마는 메모리, 보관 창고는 저장장치에 비유
    - 도마(메모리)가 핵심적인 작업 공간이고, 보관 창고(저장장치)는 보조적인 공간
    - 요리 방법을 결정하는 것은 CPU(프로세스 관리)
    - 도마 위의 재료를 정리하는 것은 메모리 관리하는 것
    - 보관 창고의 재료를 정리하는 것은 저장장치 관리하는 것
    - 도마(메모리)의 크기가 크다면 속도가 더 빠름(단, 모든 재료를 올릴 수 있으면 변화는 없음)



### 4. 하드웨어 사양 관련 용어

- **클록**
  - CPU의 속도와 관련된 단위
  - 클록이 일정 간격으로 **틱**을 만들면 거기에 맞춰 CPU 안의 모든 구성 부품이 작업
  - 버스에 여러 개의 부품이 연결되어 있는데, 메인보드의 클록이 틱을 보낼때마다 데이터를 보내거나 받음



- **헤르츠**
  - 클록틱이 발생하는 속도를 나타내는 단위(1초에 클록틱이 몇 번 발생하는지)
    - 1초에 한 번이면 1Hz, 1,000번이면 1kHz, 10억 번이면 1GHz(현재 대부분의 CPU 단위)



- **시스템 버스와 CPU 내부 버스**
  - **시스템 버스**는 메모리와 주변 장치를 연결하는 버스(**FSB(전면 버스)**)
    - 예를 들어 메인보드가 1,333MHz의 시스템 버스를 가졌고, 메모리가 800MHz라면, 메인보드가 800MHz로 작동하여 성능이 저하됨
  - **CPU 내부 버스**
    - CPU 내부에 있는 장치를 연결하는 버스(**BSB(후면 버스)**)
    - CPU 클록과 같아서 시스템 버스보다 훨씬 빠름
  - 메모리는 시스템 버스의 속도로 CPU는 CPU 내부 버스의 속도로 작동하여 작업이 지연되는 문제가 있음



## 2. CPU와 메모리

### 1. CPU의 구성과 동작

#### 1.1 CPU의 기본 구성

- **CPU**
  - 산술논리 연산장치, 제어장치, 레지스터로 구성
    - **산술논리 연산장치**
      - 데이터를 연산(+, -, *, /, AND, OR 등)하는 장치
    - **제어장치**
      - 작업을 지시하는 장치
    - **레지스터**
      - CPU 내에 데이터를 임시로 보관하는 곳



#### 1.2 CPU의 명령어 처리 과정

- 예시

  ```c
  int D2 = 2, D3 = 3, sum;
  sum = D2 + D3;
  ```

  - CPU는 0과 1의 2진수로 이루어진 기계어만 인식함

    ```assembly
    LOAD mem(100), register 2;
    LOAD mem(120), register 3;
    ADD register 5, register 2, register 3;
    MOVE register 5, mem(160)
    ```

    - 1행: 메모리의 100번지(D2)에 있는 값을 레지스터 2로 가져옴
    - 2행: 메모리의 120번지(D3)에 있는 값을 레지스터 3으로 가져옴
    - 3행: 레지스터 2와 레지스터 3에 저장된 값을 더한 결과를 레지스터 5에 넣음
    - 4행: 레지스터 5의 값을 메모리의 160번지(sum)로 옮김

  - 제어장치는 명령어를 해석하여 제어 신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할

    - "메모리에서 데이터를 가져와라", "덧셈을 실행하라", "덧셈한 결과를 메모리로 옮겨라"



#### 1.3 레지스터의 종류

- 저장의 용도로 사용되는 경우(ex - 산술 연산 후 임시 저장했다가 메모리로 옮기는 경우)
  - 사용자 프로그램에 의해 변경되기 때문에 **사용자 가시 레지스터**라 불림
  - **데이터 레지스터(DR)**
    - 메모리에서 가져온 데이터를 임시로 보관할 때 사용
    - CPU에 있는 대부분의 레지스터(때문에 일반 레지스터 또는 범용 레지스터라 불림)
  - **주소 레지스터(AR)**
    - 데이터 또는 명령어가 저장된 메모리의 주소가 저장



- 특별한 용도로 사용되는 경우

  - 사용자가 변경 불가능하기 때문에 **사용자 불가시 레지스터**라 불림

  - **프로그램 카운터(PC)**

    - CPU는 다음에 어떤 명령어를 처리할지 알아야 하는데, 프로그램 카운터가 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려줌
    - 다음에 실행할 명령어를 가리키기 때문에 **명령어 포인터**라고도 함

  - **명령어 레지스터(IR)**

    - 현재 실행중인 명령어를 저장
    - 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보냄

  - **메모리 주소 레지스터(MAR)**

    - 메모리에서 데이터를 가져오거나 반대로 메모리로 데이터를 보낼 때 주소를 지정
    - 명령어 처리 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 인식하여 해당 메모리 위치의 데이터를 가져오거나 해당 메모리 위치에 저장

  - **메모리 버퍼 레지스터(MBR)**

    - 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시로 저장
    - 항상 메모리 주소 레지스터(MAR)과 함께 동작

  - 예시

    ```assembly
    LOAD mem(100), register 2;
    ```

    1. 프로그램 카운터에는 현재 실행 중인 코드의 행 번호 1이 저장되고, 이 번호는 제어장치에 전송
       - 명령어 레지스터에는 `LOAD`가 탑재
    2. 제어장치가 명령어 레지스터에 있는 명령을 해석하여 메모리에 있는 데이터를 가져오라는 제어신호를 보냄
    3. 메모리 주소 레지스터에는 100이 저장되고, 메모리 관리자는 메모리의 100번지에 저장된 값을 메모리 버퍼 레지스터로 가져옴
    4. 제어장치는 메모리 버퍼 레지스터에 저장된 값을 레지스터 2로 옮김

  - **상태 레지스터(PSR)**

    - 결과가 양수인지 음인지, 0이 아닌지 또는 자리 올림의 유무 등을 저장
    - 플래그 레지스터, 컨디션 레지스터라고 불림

    ```c
    if (D2-D3 > 0)
    	goto 100;
    else
    	goto 200;
    ```

    - 상태 레지스터가 (D2-D3) 결과를 저장하고 있다가 음수인지 아닌지 제어장치에 알려줌



#### 1.4 버스의 종류

- **제어 버스**
  - 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 감(주변장치도 포함)
  - 메모리에서 데이터를 가져올 때는 읽기 신호를, 처리한 데이터를 메모리로 옮길 때는 쓰기 신호를 보냄
  - CPU(제어장치), 메모리, 주변장치와 양방향으로 오고 감



- **주소 버스**
  - 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할지 알려주는 위치 정보가 오고 감(주변장치도 포함)
  - CPU(메모리 주소 레지스터)와 연결되어 있으며 단방향
    - CPU에서 메모리나 주변장치로는 가지만, CPU로 전달되는 정보는 없음



- **데이터 버스**
  - 제어 버스가 다음에 어떤 작업을 할지 신호를 보내고 주소 버스가 정보를 전달하면 데이터가 데이터 버스에 실려 목적지까지 이동
  - CPU(메모리 버퍼 레지스터)와 연결되어 있으며 양방향



- **대역폭**
  - 한 번에 전달할 수 있는 데이터의 최대 크기를 의미
    - 32bit CPU, 64bit CPU라고 할 때, 32bit와 64bit가 한 번에 처리할 수 있는 데이터의 최대 크기임
  - 버스의 대역폭, 레지스터의 크기, 메모리에 한 번에 저장될 수 있는 데이터의 크기는 항상 같음
    - CPU가 한 번에 처리할 수 있는 데이터의 최대 크기를 **워드**라고 함(32bit CPU에서 1워드 = 32bit)



### 2. 메모리의 종류와 부팅

#### 2.1 메모리의 종류

- 메모리

  - **램**: 읽거나 쓸 수 있는 메모리

    - **휘발성 메모리**
      - **DRAM(Dynamic RAM)**
        - 저장된 0과 1의 데이터가 일정 시간이 지나면 사라짐
        - 일반적인 메인메모리에 사용
      - **SRAM(Static RAM)**
        - 전력이 공급되는 동안에는 데이터를 보관함
        - 캐시 같은 고속 메모리에 사용(속도는 빠르지만 비쌈)
      - **SDRAM(Synchronous Dynamic RAM)**
        - 클록틱(펄스)가 발생할 때마다 데이터를 저장하는 동기 DRAM

    - **비휘발성 메모리**
      - **플래시 메모리**
        - 각 소자의 최대 사용 횟수가 제한되어 있고, 이를 초과하면 기능을 잃음(USB, SD 카드 등)
      - **FRAM(Ferroelectric RAM)**
      - **PRAM(Phase RAM)**

  - **롬**: 읽기만 가능한 메모리이며 전력이 끊겨도 데이터는 유지되나 변경이 불가함
    - 이런 특성 때문에 바이오스를 롬에 저장함
    - **마스크 롬**
      - 데이터를 지우거나 쓸 수 없음
    - **PROM**
      - 데이터를 한 번만 저장
    - **EPROM**
      - 데이터를 여러 번 쓰고 지울 수 있으나 비쌈



#### 2.2 메모리 보호

- 메모리 보호
  - 운영체제도 하나의 소프트웨어이므로 CPU를 사용함
    - 즉, 사용자의 작업이 진행되는 동안에는 잠시 중단되므로 이때 메모리를 보호할 수 있어야 함
  - 보호 과정
    1. CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터에 저장한 후 작업
       - 또한 현재 진행 중인 작업이 차지하고 있는 메모리의 크기, 즉 마지막 주소까지의 차이를 한계 레지스터에 저장
    2. 사용자 작업이 진행되는 동안 이 두 레지스터의 주소 범위를 벗어나는 지 점검
    3. 만약, 벗어난다면 메모리 오류과 관련된 인터럽트를 발생시킴
    4. 인터럽트가 발생하면 모든 작업을 중단하고 CPU는 운영체제를 깨워 인터럽트를 처리하게 시킴
       - 주로 메모리 영역을 벗어나 발생한 인터럽트는 해당 프로그램을 강제 종료함



#### 2.3 부팅

- **부팅**
  - 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정
  - 부팅 과정
    1. 전원이 켜지면 롬에 저장된 바이오스가 실행
       - 바이오스는 CPU, 메모리, 하드디스크, 키보드, 마우스 등 주요 하드웨어가 정상 작동하는지 확인
       - 이상이 있다면 "삐~" 소리와 함께 오류 메시지를 출력
    2. 하드디스크의 **마스터 부트 레코드(MBR)**에 저장된 작은 프로그램을 메모리로 가져와 실행
       - 마스터 부트 레코드는 하드디스크의 첫 번째 섹터를 가리키며, 운영체제를 실행하기 위한 코드인 **부트스트랩**이 이곳에 저장되어 있음
       - 부트스트랩 코드는 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램
    3. 마스터 부트 레코드에 있는 부트스트랩이 메모리에 올라오면 하드디스크에 저장된 운영체제를 메모리로 불러옴



## 3. 컴퓨터 성능 향상 기술

- 일반적으로 CPU는 메모리보다 빠르고 메모리는 하드디스크 보다 빠르기 때문에 지연이 발생하는데 이를 극복하기 위한 기술을 설명



### 1. 버퍼

#### 1.1 버퍼의 개념

- **버퍼**
  - 속도에 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할
  - 예를 들어 입출력 장치에서 데이터를 가져오는 경우
    - 느린 입출력 장치에서 데이터를 읽을 때마다 하나씩 전송하면 작업량에 비해 전송되는 데이터 양이 작음
    - 일정량의 데이터를 한꺼번에 전송하면 많은 양의 데이터를 옮길 수 있음
    - 하드디스크의 성능에서 버퍼의 용량이 나오는데 이를 의미(다른게 같다면 클수록 성능이 좋음)
  - 버퍼는 하드웨어만 쓰이는 것이 아닌 동영상 스트리밍 같은 소프트웨어적으로도 사용됨



#### 1.2 스풀

- **스풀**	
  - CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼
  - 대표적으로 프린터의 스풀러(인쇄할 내용을 순차적으로 출력하는 소프트웨어)
    - 워드 프로세스를 프린터했을 때, 스풀러가 없다면
      - 모든 출력을 워드프로세서가 알아서 처리해야 하므로 인쇄가 끝날 때까지 워드프로세서를 사용할 수 없음
  - 버퍼와의 다른 점
    - 버퍼는 어떤 프로그램이 사용하는 데이터든 버퍼가 차면 이동이 시작
      - 즉, 프로그램들이 버퍼를 공유
    - 반면 스풀러는 한 인쇄물이 완료될 때까지 다른 인쇄물이 끼어들 수 없으므로 프로그램 간에 배타적



- 하드웨어 안전 제거
  - 버퍼를 사용하면 버퍼가 다 채워질 때까지 저장장치 간에 데이터 전송이 지연됨
    - USB에서 데이터를 저장 후 바로 제거하면 안되는 이유
  - 이때 하드웨어 안전 제거를 이용하면 버퍼가 저장장치에 반영되지 않은 문제가 해결됨



### 2. 캐시

#### 2.1 캐시의 개념

- **캐시**
  - 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소
  - 필요한 데이터를 모아 한꺼번에 전달하는 버퍼의 일종으로 CPU가 앞으로 사용할 것으로 예상되는 데이터를 미리 가져다놓음
    - 이렇게 미리 가져오는 작업을 **미리 가져오기(prefetch)**라고 함
  - 캐시는 CPU 안에 있으므로 CPU 내부 버스의 속도로 작동함
    - 메모리의 경우 시스템 버스의 속도로 작동하기 때문에 느림
  - CPU는 메모리에 접근해야 할 때 캐시를 먼저 방문하여 원하는 데이터가 있는지 찾음
    - 찾았다면 **캐시 히트**, 못 찾았다면 **캐시 미스**라 하며, 캐시 히트가 되는 비율을 **캐시 적중률**이라 함
      - 일반적인 컴퓨터의 캐시 적중률은 90%
    - 캐시 적중률은 성능과 연결됨
      - 이를 높이는 방법 중 하나는 캐시 용량을 키우는 것
        - 다만, 가격적인 문제가 있음
      - 또 다른 방법은 앞으로 많이 사용될 데이터를 가져오는 것
        - 현재 위치에 가까운 데이터가 멀리 있는 데이터보다 사용될 확률이 높다는 **지역성 이론**



#### 2.2 즉시 쓰기와 지연 쓰기

- 캐시에 있는 데이터를 변경한 경우 원래 데이터를 변경해야 함
  - **즉시 쓰기**
    - 캐시에 있는 데이터가 변경되면 이를 즉시 메모리에 반영하는 방식
    - 장점: 항상  최신화되어 있으므로 갑작스러운 정전 등의 상황에도 데이터를 잃어버리지 않음
    - 단점: 빈번한 데이터 전송으로 성능이 느려짐
  - **지연 쓰기**
    - 캐시에 있는 데이터가 변경되면 변경된 내용을 모아 주기적으로 반영하는 방식(**카피백**)
    - 장점: 전송 횟수가 줄어들어 시스템의 성능을 향상할 수 있음
    - 단점: 메모리와 캐시된 데이터 사이의 불일치가 발생할 수 있음



#### 2.3 L1 캐시와 L2 캐시

- 프로그램 명령어 구분
  - 어떤 작업을 할지 나타내는 명령어 부분
  - 작업 대상인 데이터 부분



- 캐시 구분
  - 명령어와 데이터의 구분 없이 모든 자료를 가져오는 일반 캐시(**L2 캐시**)
    - 메모리와 연결
  - 명령어와 데이터를 구분하여 가져오는 특수 캐시(**L1 캐시**)
    - 명령어 캐시는 명령어 레지스터와 데이터 캐시는 데이터 레지스터와 연결



- **웹 브라우저 캐시**
  - 대표적인 소프트웨어에서의 캐시 사용으로 **앞으로 다시 방문할 것을 예상하여 지우지 않는 데이터**
  - 자주 방문하는 웹 페이지의 로고나 버튼 등의 데이터를 캐시에 보관하고 있다가 다시 방문하면 캐시에 있는 데이터를 사용해 속도를 높이는 것



### 3. 저장장치의 계층 구조

- 저장장치의 계층

  | 속도  | 메모리 종류 | 용량       |
  | ----- | ----------- | ---------- |
  | 1ns   | 레지스터    | 바이트     |
  | 2ns   | 캐시        | 메가바이트 |
  | 50ns  | 메모리      | 기가바이트 |
  | 500ns | 저장장치    | 테라바이트 |

  - CPU와 메모리의 협업으로 작업하나 메모리의 속도가 CPU보다 느리므로 CPU와 가까운 쪽에 레지스터와 캐시를 배치하여 CPU 작업을 빠르게 함
  - **데이터의 일관성 유지**는 저장장치의 계층 구조, 분산된 데이터 베이스, 병령 컴퓨터의 메모리 등의 환경에서 중요한 문제



### 4. 인터럽트

#### 4.1 인터럽트의 개념

- 초기 컴퓨터
  - 시스템에서 주변장치가 많지 않았으므로 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보냄(**폴링**)
  - CPU가 입출력장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 데이터를 처리
    - CPU가 명령어 해석과 실행의 본래 역할 외의 모든 입출력까지 관여해야 하므로 작업 효율이 떨어짐



- 현재 컴퓨터
  - CPU가 입출력까지 관리하는 문제를 해결하기 위해 **인터럽트** 방식이 도입
  - **인터럽트** 방식은 CPU의 작업과 저장장치의 데이터 이동을 독릭접으로 운영하여 시스템 효율을 높임



#### 4.2 인터럽트 방식의 동작 방식

- 동작 과정
  1. CPU가 입출력 관리자에게 입출력 명령을 보냄
  2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다놓거나 메모리에 있는 데이터를 저장장치에 옮김
  3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호를 CPU에 보냄
     - 완료 신호는 인터럽트이며 CPU가 완료 신호를 받으면 하던 일을 중지하고 옮겨진 데이터를 처리함
     - 이때 입출력 장치가 여러 개일 수 있으므로 **인터럽트 번호**를 사용
       - 완료 신호를 보낼 때 장치의 이름 대신 사용하는 장치의 고유 번호로서 운영체제마다 다름
       - 윈도우는 인터럽트 번호를 **IRQ**라 하며, 키보드 IRQ는 1번, 마우스 IRQ는 12번 등으로 구분



#### 4.3 직접 메모리 접근

- **직접 메모리 접근(DMA)**
  - CPU는 입출력 관리자에게 입출력 요청을 보내고 자신의 일을 계속함
  - 입출력 관리자는 CPU가 요청한 데이터를 메모리에 가져다 놓아야 하는데, 메모리는 CPU만 접근 권한을 가진 작업 공간이므로 문제가 생김
  - 따라서, 입출력 관리자는 CPU 허락 없이 접근해야 하는데 이러한 권한을 직접 메모리 접근이라 함
    - 이 권한이 있으면 CPU의 관여 없이 작업을 완료할 수 있음



#### 4.4 메모리 매핑 입출력

- **메모리 매핑 입출력**
  - CPU가 사용하는 메모리 공간과 직접 메모리 접근을 통해 오고 가는 데이터를 위한 공간을 분리하는 것
    - 직접 메모리 접근을 사용하면 메모리에는 CPU가 사용하는 데이터와 입출력 장치가 사용하는 데이터가 섞이기 때문
    - 이를 방지하기 위해 메모리를 나누어 사용하는 메모리 매핑 입출력이 도입된 것



#### 4.5 사이클 훔치기

- CPU와 직접 메모리 접근이 동시에 발생한 경우
  - 일반적으로 CPU가 메모리 사용 권한을 양보
    - CPU의 작업 속도보다 입출력장치의 속도가 느리기 때문
  - 이러한 상황을 **사이클 훔치기**라고 부름



## 4. 병렬 처리

### 1. 병렬 처리의 개념

- **병렬 처리**
  - 동시에 여러 개의 명령을 처리하여 작업의 능률을 올리는 방식
    - 코어가 여러 개인 CPU, 코어가 하나인 CPU에서도 가능
    - **파이프라인 기법**: 하나의 코어에 여러 개의 **스레드**를 이용하여 병렬 처리
    - **슈퍼스칼라 기법**: 두 개 이상의 코어에서 여러 작업을 동시에 병렬 처리



### 2. 병렬 처리 시 고려 사항

- **상호 의존성이 없어야 병렬 처리 가능**
  - 각 명령이 서로 독립적이고 앞의 결과가 뒤의 명령에 영향을 미치치 않아야 함
- **각 단계의 시간을 거의 일정하게 맞춰야 병렬 처리가 원만**
  - 각 단계의 시간이 일정하지 않으면, 오래 시간이 걸리는 작업 대문에 진행이 전반적으로 밀려 전체 작업 시간이 늘어남
- **전체 작업 시간을 몇 단계로 나눌지 잘 결정해야 함**
  - 병렬 처리에서 작업을 N개로 쪼갰을 때 N을 병렬 처리의 깊이라 함(즉, 1이면 일반 작업)
  - 이론상은 N이 클수록 성능이 높아지나, 너무 커지면 새로운 작업을 불러오는데 시간이 많이 걸려 오히려 떨어짐
    - 이런 오버헤드를 고려하여 보통 10~20으로 함



### 3. 병렬 처리 기법

- CPU 명령어의 처리 과정

  1. **명령어 패치**: 다음에 실행할 명령어의 명령어를 레지스터에 저장
  2. **명령어 해석**: 명령어를 해석
  3. **실행**: 해석한 결과를 토대로 명령어를 실행
  4. **쓰기**: 실행된 결과를 메모리에 저장

  - 이러한 과정 전체를 하나의 스레드라 함
    - 스레드를 이루는 각 단계는 CPU의 클록과 연동되어 한 클록에 한 번씩 이루어짐



#### 3.1 파이프라인 기법

- **파이프라인 기법**
  - CPU 사용을 극대화하기 위해 명령을 겹쳐서 실행하는 방법
    - 하나의 코어에 여러 개의 스레드를 사용하는 것
  - 명령어를 여러 개의 단계로 분할한 후, 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성함
  - 여러 가지 위험
    - **데이터 위험**
      - 데이터의 의존성 때문에 발생하는 문제로 일부 명령은 앞의 명령이 끝나야 가능한 경우가 있음
    - **제어 위험**
      - 분기를 하는 if문 혹은 바로가기의 goto문 같은 명령에서 발생하는 위험
        - 프로그램 카운터 값을 갑자기 변경시켜 발생하는 위험
      - **분기 예측**이나 **분기 지연** 방법으로 해결
    - **구조 위험**
      - 서로 다른 명령어가 같은 자원에 접근하려 할 때 발생하는 문제
        - 보통 이런 문제는 해결하기 어렵다고 알려짐



#### 3.2 슈퍼스칼라 기법

- **슈퍼스칼라 기법**
  - 파이프라인을 처리할 수 있는 코어를 여러 개 구성하여 복수의 명령어가 동시에 실행하도록 하는 방법
  - 파이프라인과 마찬가지로 명령어가 상호 의존 없이 독립적이어야 하며, 이를 위한 처리도 컴파일러에서 이루어지도록 조정해야 함



#### 3.3 슈퍼파이프라인 기법

- **슈퍼파이프라인 기법**
  - 파이프라인의 각 단계를 세분화하여 한 클록 내에 여러 명령을 처리할 수 있음
    - 명령어가 빠른 시간 내에 다시 실행될 수 있어 병렬 처리 능력이 높아짐
  - 주로 크레이 슈퍼컴퓨터의 CPU에 사용됨



#### 3.4 슈퍼파이프라인 슈퍼스칼라 기법

- **슈퍼파이프라인 슈퍼스칼라 기법**
  - 앞서 나온 병렬 처리 기법을 모두 합쳐 놓은 것
    - 슈퍼파이프라인 기법을 여러 개의 코어에서 동시 수행



#### 3.5 VLIW 기법

- **VLIW**
  - CPU가 병렬 처리를 지원하지 않을 경우 소프트웨어적으로 병렬 처리하는 기법
  - 동시에 수행할 수 있는 명령어들을 컴파일러가 추출하고 하나의 명령어로 압축하여 실행
  - 앞의 병렬 처리 기법과의 차이점
    - 명령어의 수가 상대적으로 적음
    - 명령어 실행 시 병렬 처리가 아닌 컴파일 시 병렬 처리가 됨



## 5. [심화학습]무어의 법칙과 암달의 법칙

### 1. 무어의 법칙

- **무어의 법칙**
  - CPU의 속도가 24개월마다 2배 빨라진다는 법칙
  - 이 주장은 초기 CPU에만 적용되며, 지금은 자체 발열의 문제로 5GHz 이상 높이기 어렵기 때문에 멀티코어를 장착하는 방향으로 나아가고 있음



- **암달의 법칙**
  - 주변장치의 향상 없이 CPU의 속도를 2GHz에서 4GHz로 늘리더라도 컴퓨터 성능이 2배 빨라지지 않음
    - 즉, CPU의 성능을 올려도 메모리와 주변장치가 CPU의 발전 속도를 못 따라가 전반적인 성능이 저하된다는 의미
  - 이 법칙은 멀티코어에도 적용됨(CPU내 다른 부품의 병목 현상으로 인해)
