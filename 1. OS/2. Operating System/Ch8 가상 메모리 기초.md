# Chapter8 가상 메모리 기초

[[_TOC_]]

## 1. 가상 메모리 개요

- 가상 메모리: 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술
  - 컴퓨터마다 물리 메모리, 즉 실제 메모리 크기가 다름



### 1 가상 메모리 시스템

#### 1.1 가상 메모리 개념

- 가상 메모리
  - 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술
  - 만약 가상 메모리가 없다면 프로그램을 만들 때, 메모리의 크기에 큰 제약이 생김
    - 즉 메모리 크기가 다르면 실행되지 않는 프로그램이 생기게 됨



#### 1.2 가상 메모리의 크기와 주소

- 가상 메모리 주소
  - 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있던지 0번지부터 시작하는 연속 메모리 공간을 가짐
    - 논리 주소와 유사하지만, 논리 주소는 물리 메모리 주소 공간에 비례하고, 가상 주소는 가상의 주소 공간을 가진다는 차이점이 존재



- 가상 메모리의 구성
  - 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉨



- 가상 메모리 크기
  - 이론상은 무한대이나 실제로 시스템의 물리 메모리 최대 크기로 한정(ex - 32bit => 4GB)
  - 예시
    - 32bit 시스템에서 각각 4GB 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면
    - 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮김
      - 스왑 영역은 메모리 관리자가 관리하는 영역으로, 가상 메모리의 구성 요소 중 하나



- **동적 주소 변환**(**DAT**)
  - 메모리 관리자가 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는 작업
  - 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치시킬 수 있음
    - 이 과정에서 물리 메모리를 어떻게 나눌지, 사용자 프로세스를 어디에 배치할지 등의 문제를 처리함



#### 1.3 가상 메모리의 메모리 분할 방식

- 가상 메모리 시스템에서의 메모리 영역은 운영체제 영역을 제외한 나머지 부분

- 가상 메모리 시스템에서의 메모리 분할 방식은 메모리 분할 방식과 동일(세그먼테이션, 페이징)
  - 세그먼테이션은 외부 단편화로 잘 사용하지 않고, 페이징은 페이지 관리의 어려움이 있음
  - 따라서 세그먼테이션-페이징 혼용 기법을 사용



- 가상 메모리와 물리 메모리

  | 구분             | 가상 메모리                   | 물리 메모리          |
  | ---------------- | ----------------------------- | -------------------- |
  | 최대 메모리 크기 | CPU의 비트 값에 의존          | CPU의 비트 값에 의존 |
  | 메모리 분할 방식 | 세그먼테이션                  | 세그먼테이션         |
  |                  | 페이징                        | 페이징               |
  |                  | 세스먼테이션-페이징 혼용 기법 |                      |
  | 주소 지정 방식   | 가상 주소                     | 절대 주소, 상대 주소 |

  

### 2. 매핑 테이블의 필요성과 역할

- 매핑 테이블
  - 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리함
    - 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치
  - 분할 방식에 따라 **페이징 매핑 테이블**(**페이징 테이블**), **세그먼테이션 매핑 테이블**(**세그먼테이션 테이블**)



## 2. 페이징 기법

### 1. 페이징 기법의 구현

- 페이징 기법
  - 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0번부터 시작하며 각 영역은 페이지라 부름
  - 물리 메모리의 영역은 페이지와 구분하기 위해 프레임이라 부르며 0번부터 시작
  - 둘의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있음
    - 어떤 페이지가 어떤 프레임에 있는지에 대한 연결(매핑) 정보는 페이지 테이블에 담겨 있음
      - 페이지 테이블은 하나의 열로 구성(인덱스 = 페이지 번호, 값 = 프레임 번호)
      - 값은 모두 숫자가 아니라 `invalid`도 있는데 이는 해당 페이지가 스왑 영역에 있다는 의미



### 2. 페이징 기법의 주소 변환

#### 2.1 주소 변환 과정

- 가상 주소 => 물리주소 변환 과정 예시(30번지의 내용을 읽으려고 할 때)
  1. 가상 주소 30번지가 어느 페이지에 있는지 찾음(페이지 3의 0번 위치)
  2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아냄
  3. 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근(이 주소가 가상 주소 30번지의 물리 주소)



- 가상 주소 => 물리주소 변환 과정 예시(가상 주소 18번지에 값을 저장하려고 할 때)
  1. 가상 주소 18번지가 어느 페이지에 있는지 찾음(페이지 1의 8번 위치)
  2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아냄
  3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장



#### 2.2 정형화된 주소 변환

- `VA=<P,D>`
  - 페이징 기법에서 가상 주소의 표시
  - `VA`: 가상 주소, `P`: 페이지, `D`: 페이지의 처음 위치에서 해당 주소까지 거리
  - 예를 들어 18번지는 `VA=<1,8>`로 저장(페이지 하나의 크기를 10B로 규정했을 때 얘기임)



- `PA=<F,D`>
  - 페이징 기법에서 물리 주소의 표시
  - `PA`: 물리 주소, `F`: 프레임, `D`, 프레임의 처음 위치에서 해당 주소까지의 거리
  - 예를 들어 `VA=<3,0>`이 `PA=<1,0>`으로 변환됐다는 것은 가상 주소 30번지가 물리 주소의 프레임 1의 0번 위치로 변환되었다는 말
    - 여기서 D는 페이지와 프레임 크기가 똑같으므로 같음



- 페이지 테이블
  - 페이지 번호, 프레임 번호로 구성되며, 각각의 한 줄은 페이지 테이블 엔트리라고 부름
    - 즉 페이지 테이블은 페이지 번호, 프레임 번호로 구성된 페이지 테이블 엔트리의 집합
    - 단 페이지 테이블에 페이지 번호가 0부터 순서대로 정리되어 있기 때문에 굳이 페이지 번호를 표시할 필요하 없는 것



#### 2.3 16bit CPU의 주소 변환 예

- 운영체제마다 페이지의 크기는 달라짐
  - 컴퓨터는 2진법을 사용하므로 2의 지수승의 형태
  - 가상 주소를 `<P,D>`로 변환하는 공식은 다음과 같음
    - P = 나눗셈(가상 주소/한 페이지의 크기) 몫
    - D = 나눗셈(가상 주소/한 페이지의 크기) 나머지



- 16bit CPU의 예시(`VA=<6bit,10bit>`)
  - 가상 메모리 크기는 2\*\*16(65,536)B, 페이지의 개수는 2**6(64), 한 페이지의 주소의 수 2\*\*10(1,024)
    - 0번 페이지는 0~1023, 1번 페이지는 1024~2047로 구성되는 것



### 3. 페이지 테이블 관리

- 페이지 테이블 관리가 복잡한 이유
  - 시스템에 여러 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문
  - 메모리 관리자는 특정 프로세스가 실행될 때마다 해당 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 작업을 반복



- 페이지 테이블 관리
  - 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빠르게 접근을 위해 운영체제 영역의 일부분에  모아놓음
    - 한 번에 실행하는 프로세스가 많으면 페이지 테이블의 크기가 커지고 프로세스가 사용할 수 있는 메모리 영역이 줄어듬
  - 페이지 테이블의 크기 문제
    - 한 페이지가 512B인 페이징 시스템이 있고, 시스템 최대 물리 메모리 크기가 4GB인 경우
    - 이 시스템에서 한 페이지 테이블의 최대 크기는 약 24.11MB(4GB / 512B)
      - 실행 프로세스가 40개라면 약 1GB
    - 따라서 페이지 테이블의 크기를 적당하게 유지하는 것이 중요
      - 때로는 페이지 테이블도 스왑 영역에 옮겨짐



- 페이지 테이블의 레지스터
  - 레지스터는 각 프로세스의 프로세스 제어 블록에 저장되는 데이터
    - 물리 메모리 내의 페이지 테이블 시작 주소를 가짐
      - 각 페이지 테이블의 시작 주소를 **페이지 테이블 기준 레지스터**(**PTBR**)에 보관
    - 페이지 테이블에 빠르게 접근하기 위해 존재



### 4. 페이지 테이블 매핑 방식

- 페이지 테이블의 위치에 따른 매핑
  - 페이지 테이블은 운영체제의 영역에 있지만, 때로는 크기의 문제로 스왑 영역에 일부 보내지기도 함
    - 위치에 따라 가상 주소를 물리 주소로 변환하는 매핑 방식이 달라짐
  - 매핑 방식
    - **직접 매핑**
      - 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
      - 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라고 부름
      - 한 번에 바로 원하는 주소를 얻을 수 있음
    - **연관 매핑**
      - 페이지 테이블 전체를 스왑 영역에서 관리하는 방식
        - 모든 페이지 테이블을 저장장치에 스왑 영역에 저장하고 그중 일부만 물리 메모리에 보관
      - 페이지 테이블의 일부만 무작위로 가져오고, 따라서 페이지 번호와 프레임 번호 둘 다 표시함
        - 열이 2개가 되는 것
      - 직접 매핑과 달리 연관 매핑은 물리 메모리 내의 페이지 테이블을 다 검색해야 함
        - 만약 찾지 못한 경우 스왑 영역에 있는 페이지 테이블을 검색
        - 주소를 찾는데 상당한 시간을 낭비해야 함
    - **집합-연관 매핑**
      - 연관 매핑의 문제를 개선한 방식으로 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져오는 부분이 다름
        - 예를 들어 테이블을 5개씩 자르고 이를 관리하는 페이지 테이블을 하나 더 생성함
        - 새로 생성한 집합 테이블에는 일정하게 자른 페이지 테이블이 물리 메모리에 있는지, 스왑 영역에 있는지에 대한 정보를 표시
        - 이를 통해 스왑 영역에 있는지 물리 메모리에 있는지 간단히 파악하여 주소 변환 시간을 단축
    - **역매핑**
      - 물리 메모리의 프레임 번호를 기준으로 테이블을 구성
        - 즉 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시
        - 프로세스 번호(PID)와 페이지 번호 2개의 열로 구성됨
      - **장점**
        - 테이블 크기가 매우 작음(프로세스의 수와 상관없이 1개의 테이블만 존재함)
      - **단점**
        - 속도가 느림(프로세스 아이디와 페이지 번호를 모두 찾아야 가상 메모리 접근 가능)



#### 4.1 직접 매핑

- 가장 단순한 방식으로 변환 속도가 빠름



- `VA=<P,D>`를 `PA=<F,D>`로 변환하려면 페이지 테이블의 P번째 위치(PTE P)에서 원하는 프레임 값을 얻을 수 있음
  - 페이지 테이블 기준 레지스터(PTBR)의 페이지 시작 주소부터 P번째 위치



#### 4.2 연관 매핑

- **변환 색인 버퍼(TLB)** | **연관 레지스터**
  - 물리 메모리에 저장된 일부 테이블을 의미
  - **TBL 히트**: 원하는 페이지가 변환 색인 버퍼(TLB)에 있는 경우
  - **TBL 미스**: 원하는 페이지 번호가 변환 색인 버퍼(TLB)에 없는 경우



- 물리 메모리 공간을 절약할 수 있으나 속도가 느림
  - TBL 미스를 알게 되는 시점이 변환 색인 버퍼를 모두 검색하고 난 후이므로 느려짐



#### 4.3 집합-연관 매핑

- 페이지 테이블을 같은 크기의 여러 묶음으로 나누고, 각 묶음의 시작 주소를 가진 디렉터리 테이블을 새로 만들어 관리
  - 전체 테이블은 스왑 영역에 디렉터리(스왑 영역이 있는지를 표시하는)는 물리 메모리에 존재



- `VA=<P1, P2, D>`
  - `P1`: 디렉터리 테이블에서의 위치 정보(디렉터리 테이블 번호), `P2`: 묶음 내에서의 위치 정보
    - 두 단계에 걸쳐 물리 주소로 변환되는 것(**멀티페이지 매핑**)
  - 예를 들어 10개씩 한 묶음으로 나누었을 때
    - 32번지는 `<0,3,2>`, 127은 `<1,2,7>`
  - 시작 주소는 페이지 테이블 기준 레지스터(PTBR)가 가지고 있음
    - 만약 `P1`이 `I`로 되어 있으면 TLB 미스가 발생한 것이고, 반대로 물리 메모리에 있으면 묶음 테이블의 시작 주소가 명시되어 있음
  - **장점**
    - 큰 테이블을 나누어 관리하므로 효율적
    - 연관 매핑에서 TBL 미스가 발생하여 시간 낭비를 하는 것이 발생하지 않음
    - 직접 매핑과 달리 일부 테이블만 물리 메모리에서 관리하여 메모리 낭비도 적음



#### 4.4 역매핑

- 페이지를 기준으로 테이블을 구성하므로 실제 프레임 수와 행 수가 같음
  - 따라서 프로세스의 수와 상관없이 항상 일정 크기의 테이블을 유지하며 크기가 매우 작음
- 역매핑 테이블은 프로세스 번호(PID)와 페이지 번호 2개의 열로 구성됨
- **단점**
  - 속도가 느림(프로세스 아이디와 페이지 번호를 모두 찾아야 가상 메모리 접근 가능)
  - 검색 시간이 낭비됨(페이지 테이블을 다 찾은 후 저장장치에 접근하기 때문)
    - 연관 매핑과 비슷(TBL 미스)



## 3. 세그먼테이션 기법

### 1. 세그먼테이션 기법의 구현

- **세그먼테이션 테이블** | **세그먼테이션 매핑 테이블**
  - 세그먼트의 크기를 나타내는 `limit`와 물리 메모리의 시작 주소를 나타내는 `address`가 있음
    - 주어진 메모리를 넘어가면 안되므로 `limit`을 사용
  - 마찬가지로 물리 메모리가 부족할 때 스왑 영역을 사용하며 `address`에 `I`로 표시
  - **장점**
    - 메모리를 프로세스 단위로 관리하므로 페이지 테이블 작성이 단순
  - **단점**
    - 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡함



### 2. 세그먼테이션 기법의 주소 변환

- `VA=<S,D>`
  - `S`: 세그먼트 번호, `D`: 세그먼트 시작 지점에서 해당 주소까지의 거리(메모리 보호의 의미가 있음)
    - 가상 메모리 시스템에서 사용자에게 보이는 메모리를 항상 0부터 시작하므로 D는 사용자가 지정한 주소 그 자체를 의미(페이징, 세그먼테이션 모두)



- 가상 주소를 물리 주소로 변환(A의 32번지에 접근할 때)
  1. 먼저 가상 주소를 구함. 프로세스 A는 세그먼트 0으로 분할되었으므로 S는 0이고 D는 32(`VA=<0,32>`)
  2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152를 구함
     - 이때 메모리 관리자는 거리가 세그먼트 크기보다 큰지 점검
       - 크다면(메모리를 벗어나면) 오류를 출력하고 강제 종료하고 아니라면 물리 주소를 구함
       - 이때 발생하는 오류를 **트랩**이라 함
  3. 물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 씀



## 4. 세그먼테이션-페이징 혼용 기법

### 1. 메모리 접근 권한

- 메모리 접근 권한

  - 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 **읽기**, **쓰기**, **실행**, **추가** 권한이 있음

    - 네 가지 권한은 복합적으로 사용됨

  - 이론상 2**4(16)가지의 메모리 제어 방식이 나오지만, 추가 권한의 경우 쓰기 권한이 동반되어야 함

    - 결론적으로 메모리 제어 방식은 8가지가 나오게 됨(쓰기와 추가를 같이 취급)

      | 구분   | 읽기 | 쓰기 | 실행 | 비고                 |
      | ------ | ---- | ---- | ---- | -------------------- |
      | 모드 0 | X    | X    | X    | 접근 불가            |
      | 모드 1 | X    | X    | O    | 실행만 가능          |
      | 모드 2 | X    | O    | X    | 실제로 사용하지 않음 |
      | 모드 3 | X    | O    | O    | 실제로 사용하지 않음 |
      | 모드 4 | O    | X    | X    | 읽기 전용            |
      | 모드 5 | O    | X    | O    | 읽고 실행 가능       |
      | 모드 6 | O    | O    | X    | 읽고 쓰기 가능       |
      | 모드 7 | O    | O    | O    | 제한 없음            |



- 프로세스 영역별 접근 권한
  - 코드 영역: 프로세스의 몸체
    - 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가짐
  - 데이터 영역: 프로세스가 사용하는 데이터를 저장하는 영역
    - 크게 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나뉨
    - 일반적으로 변수를 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가짐
      - 상수의 경우 읽기 권한만 가짐
  - 스택 영역: 프로세스를 실행하는 데 필요한 영역



- 메모리 접근 권한 검사
  - 가상 주소에서 물리 주소로 주소 변환이 일어날 때마다 시행됨
  - 권한 밖의 작업을 하려고 하면 메모리 오류인 트랩이 발생
  - 매핑 테이블은 이러한 접근 권한에 대한 정보를 가지고 있음
    - 주소 변환이 일어날 때마다 유용한 접근인지 아닌지를 검사



### 2. 세그먼테이션-페이징 혼용 기법의 도입

- **권한 비트**
  - 페이지마다 접근 권한이 다르기 때문에 주소 변환 시 유용한 접근인지 아닌지 판단하는데 사용
  - 모든 행에 존재하게 되면 테이블의 크기가 커지고 중복되는 경우가 많아지므로 낭비
    - 세그먼테이션 테이블을 이용하여 이를 해결
      - 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리
      - 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가짐
      - 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식



- 세그먼테이션-페이징 혼용의 장점
  - 각 기법의 장점만을 이용하여 메모리 관리를 효율적으로 수행(현재 대부분의 운영체제)
  - 권한 비트, 소유 권한, 접근 권한 등을 세그먼테이션 테이블에서 관리하여 데이터 양을 줄임



### 3. 세그먼테이션-페이징 혼용 기법의 주소 변환

- 사용자 입장에서는 기본적으로 세그먼테이션 기법을 사용하고, 메모리 관리자 입장에서는 페이징 기법을 사용



- `VA=<S,P,D>`
  - `S`: 세그먼트 번호, `P`: 페이지 번호, `D`: 페이지의 처음 위치에서 해당 주소까지의 거리를 의미
    - 이는 페이징 기법의 `VA=<P,D>`에서 `S`가 추가된 것



- 가상 주소를 물리 주소로 변환 과정
  1. 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가상 주소 `VA=<S,P,D>`를 구함
  2. 세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는지, 권한이 없는 페이지에 접근하는지 등을 확인
     - 만약 검증이 안된다면 세그먼테이션 오류(트랩)을 발생시켜 강제 종료시킴
  3. 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾음
     - 만약 물리 메모리에 있다면 바로 접근하고, 없다면 스왑 영역에 가서 물리 메모리로 가져옴
  4. 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 씀



## 5. [심화학습] 캐시 매핑 기법

- 캐시의 크기는 메모리보다 작기 때문에 항상 메모리의 일부 페이지만 가지고 있음
  - 캐시에서 직접 매핑은 캐시된 데이터가 매번 같은 자리로 올라오기 때문에 캐시 테이블 전체를 찾지 않아도 캐시 히트나 캐시 미스를 바로 알 수 있음



### 1. 캐시 직접 매핑

- `<P,D>`
  - `P`: 일정 크기로 나눈 덩어리(페이지 번호)
    - 페이징 방식과 마찬가지로 일정 크기로 나눔
  - `D`: 페이지 내에서 거리



- 메모리는 N개의 페이지, 캐시는 M개의 페이지로 예시
  - N은 M보다 훨씬 많음
  - 직접 매핑에서는 메모리의 페이지 수 N을 캐시의 페이지 수 M으로 나누고 이를 **블록**이라 함
  - 메모리의 블록이 캐시에 올라올 때 항상 같은 위치에 올라옴
    - 즉 블록의 첫 번째 페이지는 캐시의 첫 번째 페이지로 올라오는 것
    - 따라서 메모리의 어떤 블록에서 올라온 페이지인지만 확인하면 됨
    - 이를 위해 블록에 번호를 매기는데 이를 **태그**라고 함
      - `<P,D>`는 `<tag,bd,D>`로 바꿀 수 있음(`bd`는 블록에서의 거리)
      - 여기서 원하는 데이터를 캐시에서 얻기 위해 `<tag,D>`를 사용



- **장점**
  - 태그만 확인하면 되므로 빠르게 캐시 히트와 캐시 미트를 확인할 수 있음



- **단점**
  - 만약 태그는 다르지만 같은 `bd`가 연달아 필요한 경우 블록 교체가 빈번해짐(자리다툼 문제)
    - 이를 연관 매핑에서 완화함



### 2. 캐시 연관 매핑

- 캐시 연관 매핑
  - 연관 매핑과 동일
  - **장점**
    - 캐시 메모리를 자유롭게 사용할 수 있음
  - **단점**
    - 캐시 히트인지 캐시 미스인지 확인하기 위해 모든 주소를 다 검색해야 하므로 느림(직접 매핑보다)



### 3. 캐시 집합-연관 매핑

- 집합-연관 매핑
  - 직접 매핑과 연관 매핑의 장점만 취한 방식
  - 캐시를 K개의 집합으로 나누고 각 집합에 직접 매핑을 사용
    - 같은 끝을 가진 캐시 메모리도 K개가 되므로 자리다툼 문제가 완화됨
