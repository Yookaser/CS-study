# Chapter7 물리 메모리 관리

[[_TOC_]]

## 1. 메모리 관리 개요

### 1. 메모리 관리의 복잡성

- 메모리 구조
  - 1B 크기로 나뉘며 각 영역은 메모리 주소로 구분(보통 0번부터 시작)
  - 폰노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간
  - 운영체제도 프로그램으로 메모리에 올라와야 실행할 수 있음
    - 따라서 메모리에는 사용자 프로세스와 운영자 프로세스가 존재
  - CPU는 메모리에 있는 내용을 가져오거나 저장하기 위해 **메모리 주소 레지스터(MAR)**를 사용
    - 메모리 주소 레지스터에 필요한 메모리 주소를 넣으면 데이터를 가져오거나 옮길 수 있음



### 2. 메모리 관리의 이중성

- 메모리 관리의 이중성
  - 프로세스는 메모리를 독차지하려 하고, 메모리 관리자는 되도록 효율적으로 관리하고 싶어 하는 것
    - 즉 프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌하는 것
  - 메모리 관리자는 프로세스에 할당된 메모리가 부족하면 옆의 프로세스를 밀어내거나 더 큰 공간으로 옮김
    - 빈 공간이 여럿 생기면 합치기 위해 프로세스를 밀어내기도 함



- 프로그램을 메모리에서 실행하는 이유
  - 메모리는 하드디스크, SSD 등에 비해 용량은 작지만 속도가 빠름
    - 또한 더 빠른 캐시 메모리를 추가로 사용함
    - 캐시 메모리는 몇 메가바이트지만 CPU의 속도로 작동함
  - `캐시 > 메모리 > 제2저장장치`처럼 계층적 메모리 구조를 만듬



### 3. 소스코드의 번역과 실행

#### 3.1 컴파일러와 인터프리터 동작

- 프로그래밍 언어
  - 응용 프로그램은 프로그래밍 언어로 만들어지며, 보통은 컴파일러를 사용하여 작성한 프로그램을 실행 가능한 코드로 바꿈
    - 바로 실행 가능하게 하려면 0과 1의 기계어로 만들어야 함
  - 언어의 구분
    - **저급 언어**: 기계어와 어셈블리어가 대표적으로 컴퓨터의 동작을 가장 직접적으로 표현한 언어
    - **고급 언어**: C, 자바 등이 대표적으로 사용자가 이해하기 쉽게 표현한 언어
  - 언어 번역 프로그램
    - 고급 언어로 작성한 소스코드를 컴퓨터가 실행할 수 있는 기계어로 변환하는 프로그램
    - **컴파일러**: 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행(C, 자바 등)
    - **인터프리터**: 소스코드를 한 행씩 번역하여 실행(자바스크립트, 베이직 등)



#### 3.2 컴파일러의 목적

- **오류 발견**
  - 오류를 발견하여 실행 시 문제가 없도록 하는 것
  - 오류를 찾기 위해 **심벌 테이블**을 이용
    - 심벌 테이블: 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블
    - 선언하지 않은 변수를 사용했는지, 변수에 다른 종류의 데이터를 저장했는지 등을 알 수 있음



- **코드 최적화**
  - 중복된 코드, 사용하지 않은 변수 등을 최적화하여 실행 속도를 높임



#### 3.3 컴파일러와 인터프리터의 차이

- 자바와 자바스크립트의 차이

  | 구분          | 자바                                                  | 자바스크립트          |
  | ------------- | ----------------------------------------------------- | --------------------- |
  | 변수          | 미리 선언해야 함                                      | 미리 선언할 필요 없음 |
  | 실행          | 컴파일 후 실행                                        | 한 줄씩 실행          |
  | 장점          | 오류 찾기와 코드 최적화, 분할 컴파일에 의한 공동 작업 | 실행이 편리           |
  | 사용 프로그램 | 대형 프로그램                                         | 간단한 프로그램       |



#### 3.4 컴파일 과정

- 컴파일

  - 사용자가 작성한 소스코드를 **목적 코드**로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정
  - `소스코드 > 컴파일러 > 목적 코드 > 링커 > 실행`(소스코드 ~ 링커까지가 컴파일)

  1. 소스코드 작성 및 컴파일
     - C나 자바로 소스코드를 작성하여 컴파일하면 **목적 코드**가 만들어짐
       - 목적 코드: 컴퓨터가 읽을 수 있는 기계어로 번역한 코드

  2. 목적 코드와 라이브러리 연결
     - **라이브러리**에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 생성
       - 라이브러리: 자수 사용하는 함수를 시스템 내에 미리 만들어둔 것(함수를 파일 형태로)
     - 예를 들어 C언어에서 `printf()`문은 컴파일러가 라이브러리 연결 단계에서 해당하는 기계어 코드를 `<stdio.h>` 라이브러리에서 가져와서 목적 코드에 삽입함
       - 여기서 `<stdio.h>` 라이브러리는 입출력 함수를 미리 만들어놓은 것

  3. 동적 라이브러리를 포함하여 최종 실행
     - **동적 라이브러리**: 실행할 때 삽입되는 함수를 가진 라이브러리
       - 예를 들어 `printf()`문의 자리를 비워놓고 컴파일 한 후 실행할 때 `printf()`문의 실행 코드를 라이브러리에서 가져와 실행
       - 예전에는 `printf()`문이 업데이트 됐다면 `<stido.h>`를 가져와 다시 컴파일해야 했음
     - 윈도우에서는 동적 라이브러리 파일을 **DDL**이라고 부름
       - 윈도우에서 함수의 변경이 일어난 경우 DDL 파일을 구하여 특정 폴더에 삽입하면 새로운 기능을 사용할 수 있음



### 4. 메모리 관리자 역할

- 메모리 관리자
  - 메모리 관리를 담당하며 정확하게는 메모리 관리 유닛이라는 하드웨어
  - 역할
    - **가져오기**
      - 프로세스와 데이터를 메모리로 가져오는 작업
        - 메모리 관리자는 사용자가 요청하면 프로세스와 데이터를 모두 메모리로 가져옴
          - 어떤 상황에서는 데이터 일부만 가져와 실행하기도 함(ex - 동영상)
          - 또한, 사용자 요청이 없더라도 앞으로 필요하다고 예상되는 데이터를 가져오기도 함
    - **배치 작업**
      - 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업
        - 배치 작업 전에 메모리를 어떤 크기로 자를지가 중요함
          - 프로세스 크기로 자르는지 같은 크기로 자르는지에 따라 메모리 관리의 복잡성이 달라짐
    - **가져오기 정책**
      - 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책
        - 일반적으로 프로세스가 요청할 때 메모리로 가져옴
          - 필요하다고 예상되는 데이터를 미리 가져오는 방법도 있음(prefetch)
    - **배치 정책**
      - 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정하는 정책
        - 같은 크기로 자르는 것을 **페이징**, 프로세스 크기에 맞게 자르는 것을 **세그먼테이션**
        - 각각의 장단점을 파악하여 메모리를 효율적으로 관리할 수 있는 정책을 만드는 것
          - 메모리가 한정되어 있기 때문으로 시스템의 효율을 좌우하는 중요한 기준
    - **재배치 정책**
      - 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정하는 정책
        - 앞으로 자주 사용하는 프로세스를 내보내면 성능이 떨어짐
        - 어떤 프로세스를 내보낼지 결정하는 알고리즘을 **교체 알고리즘**이라 함



## 2. 메모리 주소

- 메모리에 접근할 때는 주소를 이용하고 메모리 주소는 **절대 주소**와 **상대 주소**로 나뉨



### 1. 32bit CPU와 64bit CPU의 차이

- CPU 비트

  - 한 번에 다룰 수 있는 데이터의 최대 크기를 의미로 CPU 내부 부품은 이 비트를 기준으로 제작

    - 32bit CPU는 레지스터 크기, 산술논리 연산장치 등이 모두 32bit

  - 메모리 주소 공간의 크기와도 연관이 있음

    - 32bit CPU의 경우 표현할 수 있는 주소가 2**32로 약 4GB(즉, 메모리는 4GB까지 이용 가능)

  - 컴퓨터 메모리의 크기

    | 구분      | 32bit CPU         | 64bit CPU              |
    | --------- | ----------------- | ---------------------- |
    | 주소 범위 | 0 ~ (2**32-1)번지 | 0 ~ (2**64-1)번지      |
    | 총크기    | 2**32(약 4GB)     | 2**64(약 16,777,216TB) |

  - **물리 주소 공간**

    - 설치된 메모리의 주소 공간
    - 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 그 크기가 다름

  - **논리 주소 공간**

    - 사용자 입장에서 바라본 주소 공간(물리 주소 공간과 반대)



### 2. 절대 주소와 상대 주소

#### 2.1 메모리 영역 구분

- 단순 메모리 구조
  - 한 번에 한 가지 일만 처리하는 일괄 작업 시스템에서 볼 수 있음
  - 관리자는 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리
    - 예를 들어 0~359 주소는 운영체제, 360~999는 사용자
  - 사용자 영역이 운영체제 영역에 침범하는 것을 막으려면 하드웨어의 도움이 필요함
    - 이는 CPU 내에 있는 **경계 레지스터**가 담당
      - 경계 레지스터: 운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터
    - 메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터 값을 벗어나는지 검사하고, 넘어간 작업을 요청하면 프로세스를 종료시킴



#### 2.2 절대 주소와 상대 주소의 개념

- 절대 주소
  - 실제 물리 주소를 가리키며 메모리 관리자 입장에서 본 주소
    - 즉 메모리 주소 레지스터가 사용하는 주소로, 컴퓨터에 꽂힌 램 메모리의 실제 주소를 의미
  - 절대 주소를 사용하는 것은 사용자 입장에서는 불편하고 위험함
    - 운영체제가 업데이트되어 이전과 다른 주소 범위를 사용하면 운영체제의 영역을 확인해야 함
    - 운영체제 영역의 주소가 사용자에게 노출되면 실수나 고의 조작을 할 수 있음



- 상대 주소
  - 사용자 영역이 시작되는 번지를 0번지로 변경하여 사용하는 주소 지정 방식(논리 주소 공간)



- 절대 주소와 상대 주소

  | 구분      | 절대 주소                 | 상대 주소                                |
  | --------- | ------------------------- | ---------------------------------------- |
  | 관점      | 메모리 관리자 입장        | 사용자 프로세스 입장                     |
  | 주소 시작 | 물리 주소 0번지부터 시작  | 물리 주소와 관계없이 항상 0번지부터 시작 |
  | 주소 공간 | 물리 주소(실제 주소) 공간 | 논리 주소 공간                           |



#### 2.3 상대 주소를 절대 주소로 변환하는 과정

- 주소 변환
  - 절대 주소는 특별한 변환 과정없이 사용할 수 있으나 상대 주소는 절대 주소로 변경해야 함
  - 변환 작업은 프로세스가 실행되는 동안 메모리 관리자가 매우 빠르게 처리함
  - 동작 과정 예시
    1. 사용자 프로세스가 상대 주소 40번지에 있는 데이터를 요청
    2. CPU는 메모리 관리자에게 40번지에 있는 내용을 가져오라고 명령
    3. 메모리 관리자는 재배치 레지스터를 이용하여 상대 주소 40번지를 절대 주소 400번지로 변환하고 400번지에 저장된 데이터를 가져옴
       - 상대 주소 값에 재배치 레지스터 값을 더하여 절대 주소를 구함
         - 재배치 레지스터: 주소 변환의 기본이 되는 주소값을 가진 레지스터(사용자 영역의 시작 주소값이 저장됨)



## 3. 단일 프로그래밍 환경에서의 메모리 할당

### 1. 메모리 오버레이

- 메모리 오버레이
  - 프로그램의 크기가 실제 메모리보다 클 때 전체 프로그램을 가져오는 대신 적당한 크기로 잘라서 가져오는 기법
    - 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용
    - 실행하는 데 필요한 중요 모듈만 올려놓고 나머지는 필요할 때마다 가져옴
      - 예를 들어 문서 편집기에 맞춤법 검사, 그림판 등의 모듈 형태로 분리되어 있다가 필요할 때 불러오는 것
  - **프로그램 카운터(PC)**
    - 메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지 결정
    - 프로그램 카운터는 앞으로 실행할 명령어의 위치를 가리키는 레지스터로, 해당 모듈이 없으면 메모리 관리자에게 요청하여 가져오게 함



### 2. 스왑

- **스왑 영역**
  - 메모리가 모자라서 쫒겨난 프로세스를 모아두는 공간
    - 저장장치가 공간을 빌려주고 관리는 메모리 관리자가 함(원래 저장장치는 저장장치 관리자가 함)
    - **스왑인**: 스왑 영역에서 메모리로 데이터를 가져오는 작업
    - **스왑아웃**: 메모리에서 스왑 영역으로 데이터를 내보내는 작업
  - 스왑 영역이 필요한 이유
    - 메모리에 모듈 B를 가져올 때 먼저 메모리에 올라온 모듈 A를 어딘가에 보관해야 함
    - 하드디스크로 옮기면 되겠지만, 다시 사용할지 모르고 아직 작업이 끝나지 않았기 때문에 별도의 저장장치에 보관해야 함
  - 사용자는 실제 메모리 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용할 수 있게 됨



- 최대 절전 모드
  - 현재 작업 중인 상태 그대로 쉬게 하는 것으로 전력 공급이 잠시 끊기므로 메모리의 내용이 사라지지만, 스왑 영역에 모두 보관했다가 다시 가져오는 것



## 4. 다중 프로그래밍 환경에서의 메모리 할당

### 1. 메모리 분할 방식

- **가변 분할 방식**: 프로세스의 크기에 따라 메모리를 나누는 것
- **고정 분할 방식**: 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것



#### 1.1 가변 분할 방식과 고정 분할 방식

- 고정 분할 방식은 모든 크기가 같으므로 관리의 측면에서 편함
  - 또한, 프로세스가 작업 도중 메모리 주소를 옮길 필요가 없음



#### 1.2 메모리 분할 방식의 구현

- **가변 분할 방식**
  - 프로세스의 크기에 맞게 메모리가 분할되므로 메모리의 영역이 각각 다름
  - 한 프로세스가 연속된 공간에 배치되므로 **연속 메모리 할당**이라 함
  - **장점**
    - 프로세스를 한 덩어리로 처리하여 하나의 프로세스가 연속된 공간에 배치됨
  - **단점**
    - 메모리 관리가 복잡(메모리 통합, 이동 등의 부가적인 작업)



- **고정 분할 방식**
  - 프로세스의 크기와 상관 없이 메모리가 같은 크기로 나뉨
    - 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치
  - 한 프로세스가 분산되어 배치되므로 **비연속 메모리 할당**이라 함
  - **장점**
    - 메모리 관리가 수월(메모리 통합, 이동 등의 부가 작업 X)
  - **단점**
    - 쓸모없는 공간이 생겨 메모리 낭비가 발생할 수 있음



- 현대의 운영체제에서 메모리 관리는 기본 고정 분할 방식을 사용하며 일부분 가변 분할 방식을 혼합함



### 2. 가변 분할 방식의 메모리 관리

- 가변 분할 방식을 **세그먼테이션 기법**이라고도 함



#### 2.1 프로세스 배치와 외부 단편화

- **단편화**(**조각화**)
  - 빈 영역이 있어도 서로 떨어져 있어 프로세스를 배정하지 못하는 문제
    - 예를 들어 프로세스가 메모리에서 나갔을 때, 그 영역에 더 큰 프로세스가 들어와야 하는 경우
  - 개선 방법
    - **메모리 배치 방식**: 작은 조각이 발생하지 않도록 프로세스를 배치하는 것(선처리)
    - **조각 모음**: 작은 조각들을 모아서 하나의 큰 덩어리로 만느는 작업(후처리)



#### 2.2 메모리 배치 방식

- **최초 배치**
  - 프로세스를 메모리의 빈 공간에 배치할 때 순차적으로 찾다 발견한 최초 공간에 배치하는 방법
    - 단편화를 고려하지 않는 것



- **최적 배치**
  - 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 배치하는 방법



- **최악 배치**
  - 최적 배치와 정반대로 빈 공간을 모두 확인한 후 가장 큰 공간에 배치하는 방법
  - 빈 공간이 많을 때는 효과적이지만, 빈 공간이 줄어들면 최적 배치처럼 작은 조각을 만들어냄



#### 2.3 조각 모음

- **조각 모음**
  - 여러 개의 빈 공간을 합치는 작업
  - 동작 과정
    1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춤
    2. 프로세스를 적당한 위치로 이동(원래 위치에서 이동하므로 프로세스의 상대 주소를 바꿈)
    3. 이러한 작업을 다 마친 후 프로세스를 다시 시작
  - **단점**
    - 시간이 많이 걸리고 복잡함
  - 조각 모음이 필요한 이유
    - 어떤 메모리 배치 방식을 사용해도 단편화는 발생함(근본적 문제를 해결하지 못함)



### 3. 고정 분할 방식의 메모리 관리

- 고정 분할 방식을 **페이징**이라고도 함
  - 관리하기 편하나 여러 곳으로 분할되어 저장되는 것이 문제



#### 3.1 프로세스 배치와 내부 단편화

- 고정 분할 방식은 가변 분할 방식보다 공간을 효율적으로 관리하여 조각 모음이 필요 없음



#### 3.2 내부 단편화

- 내부 단편화
  - 일정하게 나뉜 메모리보다 작은 프로세스가 배치될 경우 공간이 남아 낭비되는 현상
    - 즉 일정하게 나뉜 파티션 안쪽에서 작은 조각이 발생함
  - 개선 방법
    - 결국 적당한 크기로 나누는 수밖에 없음
    - 너무 크면 내부 단편화가 급격히 늘어나고, 너무 작으면 여러 개로 분할되어 관리가 어려움



- 가변 분할 방식과 고정 분할 방식의 비교

  | 구분        | 가변 분할 방식                   | 고정 분할 방식             |
  | ----------- | -------------------------------- | -------------------------- |
  | 메모리 단위 | 세그먼테이션                     | 페이징                     |
  | 특징        | 연속 메모리 할당                 | 비연속 메모리 할당         |
  | 장점        | 프로세스를 한 덩어리로 관리 가능 | 메모리 관리가 편리         |
  | 단점        | 빈 공간의 관리가 어려움          | 프로세스가 분할되어 처리됨 |
  | 단편화      | 외부 단편화                      | 내부 단편화                |



### 4. 버디 시스템

- 가변 분할 방식의 외부 단편화를 완화하는 방법(고정 분할과 유사한 점이 있음)



#### 4.1 버디 시스템의 작동 방식

- 버디 시스템
  - 가변 분할과 고정 분할의 중간 구조
  - 동작 과정
    1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치
    2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어감
    3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만듬



#### 4.2 버디 시스템의 특징

- 가변 분할 방식보다 효과적인 공간 관리가 가능한 이유
  - 비슷한 크기의 덩어리가 서로 모여 있어 통합하기가 쉽기 때문
  - 가변 분할 방식에서는 작은 조각이 큰 조각 사이사이에 있어 조각을 모으려면 큰 덩어리를 옮겨야 함



- 버디 시스템의 공간 관리 효율
  - 고정 분할 방식과 비슷한 수준
  - 하지만 메모리를 똑같은 크기로 나누어 사용하는 고정 분할 방식이 메모리 관리 측면에서 더 단순하기 때문에 고정 분할 방식이 많이 사용됨



## 5. [심화학습] 컴파일과 메모리 관리

### 1. 컴파일 과정

- 과정
  - 고급 언어를 컴파일러가 목적 코드로 변환
    - 오류 점검, 최적화 등
    - 목적 코드는 기계어로 가기 직전의 초벌 번역 상태라고 보면 됨
  - 목적 코드에 라이브러리 코드를 삽입하여 최종 실행 파일을 만듬



- 분할 컴파일
  - 소스코드를 컴파일하여 목적 코드로 만든 후 목적 코드만 모아 컴파일 하는 것
  - 예를 들어 여러 프로그래머의 소스코드를 합치는 경우 아직 오류에 대한 검증이 없었으므로 오류가 발생할 수 있는데, 이때 각자 오류를 수정하여 소스코드를 합치는 것이 아닌 각각의 소스코드를 컴파일하여 목적 코드를 만들어 합치는 것



### 2. 변수와 메모리 할당

- 컴파일 과정에서 가장 중요한 것은 메모리를 확보하고 정리하는 부분
  - 컴파일러는 모든 변수를 메모리 주소로 바꾸어 기계어로 된 실행 파일을 만듬
    - 즉 프로그래머가 만든 변수를 적당한 크기의 메모리 주소로 변환하여 기계어로 바꾸는 것
    - 여기서 컴파일러에 의해 만들어진 주소는 상대 주소임



- 심벌 테이블의 예시

  | 심벌 | 종류  | 범위   | 주소 |
  | ---- | ----- | ------ | ---- |
  | str  | char  | main() | 0    |
  | vol  | int   | main() | 1    |
  | pri  | float | main() | 5    |
