# Chapter5 프로세스 동기화

[[_TOC_]]

## 1. 프로세스 간 통신

### 1. 프로세스 간 통신의 개념

- 프로세스 통신
  - 프로세스가 다른 프로세스와 데이터를 주거나 받는 것
    - 컴퓨터 내 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터의 프로세스와의 통신도 포함
  - 종류
    - **프로세스 내부 데이터 통신**
      - 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신
      - 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고받음
        - 운영체제의 도움 없이 진행되는 통신 방식
    - **프로세스 간 데이터 통신**
      - 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신
    - **네트워크를 이용한 데이터 통신**
      - 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 소켓을 이용
      - 다른 컴퓨터에 있는 함수를 호출하여 통신하는 원격 프로시저도 포함



### 2. 프로세스 간 통신의 분류

#### 2.1 통신 방향에 따른 분류

- 데이터가 전송되는 방향에 따른 분류

  - **양방향 통신**
    - 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조(ex - 소켓 통신을 포함한 일반적인 통신들)
  - **반양방향 통신**
    - 데이터를 양방향 전송할 수 있으나 동시에는 불가능한 구조(ex - 무전기)

  - **단뱡향 통신**
    - 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조(ex - 전역 변수와 파이프)



- 전역 변수
  - 전역 변수는 우편함 역할을 하며, 보내는 사람이 우편함에 편지를 넣으면 받는 사람이 우편함을 열어 꺼내감
  - 전역 변수를 1개만 이용하여 양방향으로 데이터를 보내면 2개 중 하나는 지워짐
    - 즉, 양방향 통신을 구현하려면 전역 변수를 2개 사용해야 함



- 함수 호출
  - 함수는 하나의 프로세스내에서 순차적으로 실행되기 때문에 통신이라고 부르지 않음



#### 2.2 통신 구현 방식에 따른 분류

- 전역 변수의 단점
  - 언제 데이터를 보낼지 받는쪽은 모르므로 반복적으로 전역 변수의 값을 점검해야 함
    - 즉, 우편함에 편지가 있는지 상태 변화를 확인하는 무한 반복문을 실행하며 기다림(**바쁜 대기**)
  - 시스템 차원에서는 큰 자원 낭비
  - **바쁜 대기**를 해결하기 위해 도착했음을 알리는 동기화를 사용(운영체제가 알아서 알려줌)



- 동기화 여부에 따른 통신
  - **대기가 있는 통신**
    - 동기화를 지원하는 통신 방식
    - 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머뭄
  - **대기가 없는 통신**
    - 동기화를 지원하지 않는 통신 방식
    - 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인



- 프로세스간 통신의 분류

| 분류 방식                  | 종류             | 예                      |
| -------------------------- | ---------------- | ----------------------- |
| 통신 방향에 따른 분류      | 양방향 통신      | 일반적 통신, 소켓       |
|                            | 반양방향 통신    | 무전기                  |
|                            | 단방향 통신      | 전역 변수, 파일, 파이프 |
| 통신 구현 방식에 따른 분류 | 대기가 있는 통신 | 파이프, 소켓            |
|                            | 대기가 없는 통신 | 전역 변수, 파일         |



### 3. 프로세스 간 통신의 종류

- 프로세스간 통신

  - 프로세스 간 통신은 데이터를 주거나 받는 동작으로 이는 쓰기 연산과 읽기 연산으로 간소화 가능

  ```c
  send -> write(GV, message)
  receive -> read(GV, message)
  ```

  - 전역 변수 GV를 이용하여 send는 쓰기, receive는 읽기 연산으로 변경한 것
    - 이러한 프로세스 간 통신 방식은 전역 변수, 파일, 파이프, 소켓에도 동일하게 적용



#### 3.1 전역 변수를 이용한 통신

- 전역 변수
  - 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 것으로 
    - 보내는 쪽은 전역 변수나 파일에 값을 쓰고, 받는 쪽은 전역 변수의 값을 읽음
  - 주로 직접 관련 있는 프로세스간 사용(ex - 부모 프로세스가 전역 변수를 선언 후 자식을 만들면 통신 가능)
    - 서로 연관이 없는 프로세스 간 통신에도 `extern` 변수와 같은 전역 변수를 사용할 수 있음
  - 예시
    - 양방향 통신을 위해 R과 L을 정의 후 `fork()`를 사용하여 부모 프로세스(P)와 자식 프로세스(C)를 만든 경우
      - 두 프로세스는 전역 변수에 읽기 또는 쓰기 연산을 함
        - P는 R을 통해 write하면 C는 R을 read하고 L로 write하는 것
      - 이 경우 P는 L을 C는 R을 계속 바쁜 대기 상태로 있어야 함



#### 3.2 파일을 이용한 통신

- 파일

  - 파일 입출력 코드

  ```c
  #include <stdio.h>
  #include <unistd.h
  #include <fcntl.h>
  
  int main() {
      int fd;
      char buf[5];
      
      fd=open("com.txt", O_RDWR)
      write(fd, "Test", 5)
      read(fd, buf, 5)
      close(fd)
      exit(5)
  }
  ```

  - **파일 열기**
    - 첫 부분인 `open()`은 준비 단계로 사용하고자 하는 파일이 있는지, 있다면 쓰기 권한이 있는지도 확인
    - 어떠 파일을 쓰거나 읽기 연산을 하려면 `fd`를 얻고 작업이 다 끝나면 돌려줘야 함
      - **파일 기술자**: 어떤 파일에 접근할 수 있는 권한인 fd를 부르는 말
    - `open("com.txt", O_RDWR)`
      - `O_RDWR`는 읽기와 쓰기 작업을 하겠다는 것(읽기 전용이라면 `O_RDONLY`)
  - **읽기 또는 쓰기 연산**
    - `write(fd, "Test", 5)`
      - `fd`, 즉 com.txt 파일에 Test라는 문자열을 쓰라는 것(5는 Test의 크기가 5B이므로 명시한 것)
    - `read(fd, buf, 5)`
      - `fd`, 즉 com.txt 파일에서 5B를 읽어 변수 buf에 저장하라는 뜻
  - **파일 닫기**
    - `close(fd)`
      - fd가 가리키는 파일, 즉 com.txt 파일을 닫음



#### 3.3 파이프를 이용한 통신

- 파이프
  - 운영체제가 제공하는 통신 방식으로, 파일 입출력과 같이 `open()`으로 시작해 `close()`로 마무리함
  - 파이프 또한 단방향 통신이므로 양방향을 위해서는 파이프 2개를 사용해야 함(단, 동기화되어 있음)
  - 종류
    - **이름 없는 파이프**
      - 일반적인 파이프로 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 등 서로 관련 있는 경우 사용
    - **이름 있는 파이프**
      - FIFO라 불리는 특수 파일을 이용하여 서로 관련 없는 프로세스 간 통신에 사용



#### 3.4 소켓을 이용한 통신

- 소켓
  - 여러 컴퓨터에 있는 프로세스 간 통신(네트워킹)에서 사용
  - 다른 컴퓨터의 프로세스와 통신하려면 그 컴퓨터의 위치를 파악하고, 원격지의 시스템 내 여러 프로세스 중 어떤 프로세스와 통신을 할지도 결정해야 함
  - 동기화를 지원하므로 바쁜 대기를 하지 않아도 되며, 하나만 이용해도 양방향이 가능



#### 3.5 정리

| 종류      | 운영체제 동기화 지원 | open()/close() 사용 |
| --------- | -------------------- | ------------------- |
| 전역 변수 | X(바쁜 대기)         | X                   |
| 파일      | X(wait() 함수 이용)  | O                   |
| 파이프    | O                    | O                   |
| 소켓      | O                    | O                   |



## 2. 공유 자원과 임계구역

### 1. 공유 자원의 접근

- 공유 자원
  - 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 의미
  - 누가 언제 데이터를 읽거나 쓰냐에 따라 결과가 달라질 수 있으므로 접근 순서를 정해야 함
    - **경쟁 조건**: 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 문제



### 2. 임계구역

- 임계구역
  - 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
  - 프로세스 실행 상황에서는 공유할 수 없는 자원



#### 3. 생산자-소비자 문제

- 생산자-소비자 문제
  - 임계구역의 전통적 문제
  - 생산자는 계속 물건을 버퍼에 넣고 소비자는 계속 버퍼에서 물건을 가져감
    - 버퍼는 작업을 계속하기 위해 원형 버퍼를 이용
    - 또한, 버퍼가 상태를 확인하기 위해 `sum` 전역 변수를 사용(현재 버퍼에 있는 물건의 수)
  - 문제의 발생(`sum`에 접근하는 타이밍을 맞추기 않았기 때문)
    - 생산자가 물건 하나를 buf 4에 저장(`sum`을 4로 바꿔야 하나 아직 못바꿈)
    - 소비자가 물건 하나를 소비(`sum`을 2로 바꿔야 하나 아직 못바꿈)
    - 이 상태에서 생산자의 `sum=sum+1`과 소비자의 `sum=sum-1`이 거의 동시에 실행되면 문제가 발생
      - 생산자 소비자가 독립적이므로 상대가 현재 `sum`을 바꾸려는 것을 모른채 진행함



### 4. 임계구역 해결 조건

- **상호 배제**
  - 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없음
- **한정 대기**
  - 프로세스가 무한 대기를 하면 안됨, 즉 특정 프로세스가 임계구역에 접근하지 못하면 안됨
- **진행의 융통성**
  - 프로세스들의 작업 속도와 관계없이 임계구역이 비어있으면 언제든지 사용 할 수 있어야 함
    - 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다는 것을 의미



## 3. 임계구역 해결 방법

- 잠금
  - 가장 단순한 방법으로 한 프로세스가 사용하면 잠그고 나오면 잠금을 해제하는 것



### 1. 기본 코드 소개

- boolean 변수는 true와 false만을 가지므로 잠금을 표현하기에 가장 적합

  - 다만 C 언어에는 boolean이 없어 새로 정의했고, 잠금으로 사용할 전역 변수 lock과 임계구역에 사용할 예금 변수 balance도 정의

  ```c
  #include <stdio.h>
  
  typedef enum {false, true} boolean;
  extern boolean lock=false;
  extern int balance;
  
  main() {
      while(lock==true);
      lock=true;
      balance=balance+10;
      lock=false;
  }
  ```



### 2. 임계구역 해결 조건을 고려한 코드 설계

#### 2.1 상호 배제 문제

- lock
  - lock의 초깃값은 false로 잠금이 해제되었다는 의미



```c
//공유 변수
boolean lock=false;

//P1 프로세스
while(lock==true);
lock=true;
	//임계구역
lock=false;
```

- 프로세스 P1과 P2는 임계구역에 접근하기 전에 코드를 통해 임계구역에 잠금이 걸려 있는지 확인
  - 잠겨 있으면 잠금이 해제될 때가지 무한 루프를  돌며 기다림
  - 잠금이 해제되면 무한 루프를 빠져나와 작업을 함

- 위의 코드는 위의 절차를 제대로 수행하지 못하는 상황이 존재

  1. 프로세스 P1은 while 문을 실행
     - 임계구역에 프로세스가 없기 대문에 무한 루프를 빠져나오고 다음 문장을 실행하려는 순간 CPU 시간을 다 써서 준비 상태로 옮겨지고, 문맥 교환이 발생한 뒤 P2가 실행 상태로 바뀜
  2. 프로세스 P2는 while문을 실행
     - 아직 P1이 잠금을 걸지 않았으므로 접근 가능
  3. 프로세스 P1은 `lock=true;`문을 실행하여 임계구역에 잠금을 걸고 진입
  4. 프로세스 P2도 `lock=true;`문을 실행하여 임계구역에 진입

  - 위와 같은 상황에서는 상호 배제를 보장할 수 없음
  - 또 다른 문제로는 잠금이 풀리기까지 바쁜 대기를  해야 한다는 것
    - 작업을 할 필요가 없는 시간에도 무한 루프를 돌면서 시스템 자원을 낭비함



#### 2.2 한정 대기 문제

- 상보 배제 문제의 코드를 보완

  ```c
  //공유 변수
  boolean lock1=false;
  boolean lock2=false;
  
  //P1 프로세스
  lock1=true;
  while(lock2==true);
  	//임계구역
  lock1=false;
  ```

  - P1은 임계구역에 진입하기 전에 먼저 잠금을 설정하고 프로세스 P2가 잠금을 설정했는지 확인

    - 설정하지 않은 경우 임계구역에 진입하여 작업을 마친 후 잠금을 해제

  - 즉, 잠금을 2개 사용하여 상호 배제를 보장

  - 하지만 임계구역에 진입하지 못하는 무한 대기의 문제가 발생

    1. 프로세스 P1은 `lock1=true;`문을 실행한 후 자신의 CPU 시간을 다 써버리고, 문맥 교환이 발생한 뒤 P2가 실행 상태로 바뀜
    2. 프로세스 P2도`lock2=true;`문을 실행한 수 타임아웃 후, 문맥 교환이 발생하고 프로세스 P1이 실행 상태로 바뀜
    3. P1은 `lock2=true;`이므로 무한 루프에 빠짐
    4. P2는 `lock1=true;`이므로 무한 루프에 빠짐

    - 이처럼 한정 대기 조건을 보장하지 못하는 상황을 **교착 상태**라고 함
      - 프로세스가 살아있으나 작업이 진행되지 못하는 상황
    - 또한, 확장성의 문제가 있는데 프로세스의 개수만큼 전역 변수가 늘어가 검사 개수도 늘어나게 됨



#### 2.3 진행의 융통성 문제

- 한정 대기 문제의 코드를 보완

  ```c
  //공유 변수
  int lock=1;
  
  //P1 프로세스
  while(lock==2);
  	//임계구역
  lock=2;
  ```

  - lock 값이 1이면 P1이 임계구역을 사용함을 의미하고, 임계 구역을 빠져나올 때 lock을 2로 바꾸는 것
  - 그러나 프로세스 P1은 프로세스 P2가 임계구역에 진입했다가 나온 다음에야 진입할 수 있으므로 프로세스 P2가 프로세스 P1의 진행을 방해하는 구조
    - 이를 **경직된 동기화**라고 함



#### 2.4 하드웨어적인 해결 방법

- while문과 `lcok=true;`문의 동시에 실행

  ```c
  while(testandset(&lock)==True)
  	//임계구역
  lock=false;
  ```

  - 이렇게 하면 타임아웃에 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않음
  - 이 방법은 편리하나 바쁜 대기를 사용해서 검사하기 때문에 자원 낭비가 있음



- 아직 임계구역 해결 조건을 완벽히 충족하지 못함
  - 피터슨 알고리즘이 이를 해결했으나 구조가 복잡하여 현재는 잘 사용되지 않음



### 3. 피터슨 알고리즘

- 피터슨 알고리즘

  - 기존과 비슷한데 turn이라는 공유 변수를 더 사용

  ```c
  //공유 변수
  boolean lock1-false;
  boolean lock2=false;
  int turn=1;
  
  //P1 프로세스
  lock1=true;
  turn=2;
  while(lock2==true && turn==2);
  	//임계구역
  lock1=false;
  ```

  - 프로세스 P1은 임계구역에 진입하기 전 먼저 잠금을 한 후 turn을 2로 지정
    - 변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계구역에 못 들어가는 상황을 막기 위한 장치
    - 즉, 두 프로세스가 lock을 설정했어도 turn을 이용해 다른 프로세스에 양보함
  - 이어 while문을 실행하고 만약 프로세스 P2가 잠금을 설정하지 않았거나 turn=1로 바꾸면 프로세스 P1은 임계구역에 진입하여 작업을 마친 후 잠금을 해제하고 임계구역을 빠져나옴
  - 세 가지 조건 모두 만족하나 더 많은 프로세스가 하나의 임계구역을 사용하려면 공유 변수를 더 추가해야함



### 4. 데커 알고리즘

- 데커 알고리즘

  - 하드웨어의 도움 없이도 임계구역의 문제를 해결할 수 있는 알고리즘

  ```C
  //공유 변수
  boolean lock1-false;
  boolean lock2=false;
  int turn=1;
  
  //P1 프로세스
  lock1=true;
  while(lock2==true) {
      if(turn==2) {
          lock1=false;
          while(turn==2);
          lock1=true;    }
  }
  	//임계구역
  turn=2;
  lock1=false;
  ```

  - P1의 입장에서
    1. 프로세스 P1은 우선 잠금을 검
    2. 프로세스 P2의 잠금이 걸렸는지 확인
    3. 만약 프로세스 P2도 잠금이 걸었다면 누가 먼저인지 확인. 만약 프로세스 P1 차례라면(turn=1) 임계구역으로 진입하고 만약 프로세스 P2 차례라면(turn==2) 4로 이동
    4. 프로세스 P1은 잠금을 풀고 프로세스 P2가 작업을 마칠 때까지 기다림. 프로세스 P2가 작업을 마치면 잠금을 걸고 임계구역으로 진입
  - 피터슨과 마찬가지로 세 가지 조건을 만족하나 프로세스가 늘어나면 변수도 늘고 복잡함



### 5. 세마포어

- 세마포어

  - 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역에 들어감
  - 이후 도착하는 프로세스는 앞의 프로세스가 작업을 마칠때까지 기다리고 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보냄
    - 즉, 임계구역이 잠겼는지 직접 점검하거나, 바쁜 대기를 하거나, 다른 프로세스에 동기화 메시지를 보낼 필요가 없음

  ```c
  Semaphore(n);
  P();
  	// 임계구역
  V();
  ```

  - **Semaphore(n)**
    - 전역 변수 RS를 n으로 초기화(RS에는 현재 사용 가능한 자원의 수가 저장)
  - **P()**
    - 잠금을 수행하는 코드로, RS가 0보다 크면(사용 가능한 자원이 있음) 1만큼 감소시키고 임계구역에 진입
    - 만약 RS가 0보다 작으면(사용 가능한 자원 없음) 0보다 커질때가지 대기
  - **V()**
    - 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 `wake_up` 신호를 보냄
    - 세마포어에서 잠금이 해제되기 기다리는 프로세스는 세마포어 큐에 저장되어 있음
  - 만약 `P()`와 `V()`가 내부 코드 실행 중 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못하므로 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 함



### 6. 모니터

- 세마포어의 문제
  - 잘못된 사용으로 인해 임계구역이 보호받지 못하는 것이 가장 큰 문제
  - 상황
    1. 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간 경우 임계구역을 보호할 수 없음
    2. `P()`를 두 번 사용하여 `wake_up` 신호가 발생하지 않은 경우 프로세스 동기화가 이뤄지지 않아 무한 대기에 빠짐
    3. `P()`와 `V()`를 반대로 사용하여 상호 배제가 보장되지 않은 경우 임계구역을 보호할 수 없음
  - 공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따르면 굳이 `P()`와 `V()`를 사용할 필요 없이 자동으로 처리하면 됨 => **모니터**



- 모니터
  - 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시킴
  - 시스템 호출과 같은 개념
  - 작동 원리
    1. 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 `P()`나 `V()`를 사용하지 않고 모니터에 작업 요청
    2. 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에 알려줌
  - 임계구역 보호와 동기화를 위해 내부적으로 **상태 변수**를 사용함
    - **wait()**: 모니터 큐에서 자신의 차례가 올 때까지 대기(세마포어의 `P()`에 해당)
    - **signal()**: 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨움(세마포어의 `V()`에 해당)



## 4. [심화학습] 파일, 파이프, 소켓 프로그래밍

- 유닉스로 알아보는 파일, 파이프, 소켓 프로그래밍



### 1. 파일

#### 1.1 순차 파일

- 순차 파일
  - 파일 내의 데이터가 한 줄로 길게 저장되는 파일
  - 순차 파일에 접근하는 방식을 **순차적 접근**이라 함



#### 1.2 파일 기술자

- 파일 입출력 코드

  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <fcntl.h>
  
  void main() {
  	inf fd;
  	char buf[5];
  	
  	fd=open("com.txt", O_RDWR);
  	read(fd, buf, 5);
  	printf("%s", buf);
  	close(fd);
  	return 0;
  }
  ```

  - 파일 기술자는 파일 접근 권한 외의 현재 파일의 어느 위치를 읽고 있는지에 대한 정보도 보관
    - 처음 파일이 열리면 기술자는 맨 앞에 위치
    - 파일에서 파일 기술자는 단 하나이고, 읽기든 쓰기든 계속 전진함



#### 1.3 파일을 이용한 통신

- 부모 프로세스와 자식 프로세스가 파일을 이용하여 통신하는 코드

  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <fcntl.h>
  
  void main() {
  	int pid, fd;
  	char buf[5];
  	
  	fd=open("com.txt", O_RDWR);
  	pid=fork();
  	
  	if(pid<0 || fd<0) exit(-1);
  	
  	else if(pid==0) {
  		write(fd, "Test", 5);
  		close(fd);
  		exit(0);	}
  	else {
  		wait(0);
  		lseek(fd, 0, SEEK_SET);
  		read(fd, buf, 5);
  		printf("%s", buf);
  		close(fd);
  		exit(0);	}
  }
  ```

  - 부모 프로세스가 자식보다 먼저 실행되면 빈 내용을 읽게 되므로 동기화를 해 주어야 함
    - 부모는 자식의 작업이 끝난 후 `read()`를 수행해야 하므로 `wait()`를 사용하여 자식을 기다림
    - 자식이 작업을 마치면 `lseek()`가 실행되어 파일 기술자가 맨 앞으로 옮겨짐
    - 그 후 읽은 데이터를 화면에 출력하여 파일 기술자를 닫고 프로그램을 끝냄
  - `fork()`는 파일 기술자도 복사를 함
    - 즉 `open()`은 한 번이나 `close()`는 자식과 부모에서 총 두 번 발생함
    - 복사가 되었으므로 파일 기술자의 위치는 공유함
  - `lseek()`를 통해 자식에서 움직인 위치를 초기로 돌려 놓음
    - `lseek()`은 파일 기술자를 움직이는 명령어로 SEEK_SET은 맨 처음, SEEK_CUR은 현재 위치, SEEK_END는 맨 마지막
    - 즉 여기서 `lseek(fd, 0, SEEK_SET);`와 `lseek(fd, -5, SEEK_CUR);`는 같은 의미



### 2. 파이프

- 파이프를 이용한 자식 프로세스가 Test라는 문자를 부모에 전달하는 코드

  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <fcntl.h>
  
  void main() {
  	int pid, fd[2];
  	char buf[5];
  	
  	if(pipe(fd)==-1) exit(-1);
      pid=fork();
  	
  	if(pid<0) exit(-1);
  	
  	else if(pid==0) {
  		close(fd[0]);
          write(fd[1], "Test", 5);
          close(fd[1]);
  		exit(0);	}
  	else {
  		close(fd[1]);
  		read(fd[0], buf, 5);
  		close(fd[0]);
  		printf("%s", buf);
  		exit(0);	}
  }
  ```

  - 파일과 파이프 통신의 차이점
    - 파일은 `read()`와 `write()`가 파일 기술자를 공유하나 파이프는 `read()`와 `write()`에 따로 존재
    - 파일은 파일 기술자를 공유하므로 기술자가 전진하여 동기화할 수 없음
      - 반면 파이프는 각각 존재하므로 동기화할 수 있음
    - 부모에 `wait()`가 없음
      - 자식과 부모 중 어떤 프로세스가 먼저 실행되는지 보장할 수 없지만, 파이프는 대기가 있는 통신이므로 `wait()`가 불필요
  - 파이프에서 fd[2]로 선언한 후 `fork()`를 하면 부모 프로세스에 fd[2], 자식 프로세스에 fd[2], 총 4개의 파일 기술자가 존재(따라서 `close()`도 네 번 나옴)
    - 단방향 통신이므로 프로세스당 하나의 파일 기술자만 사용하여 필요 없는 파일 기술자는 닫아 버림



### 3. 네트워킹

- 클라이언트 코드

  ```c
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <netdb.h>
  
  void main() {
  	int sp;
  	char buf[5];
  	struct sockaddr_in ad;
  	
  	sp=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  	
  	memset(&ad, 0, sizeof(ad));
  	ad.sin_family=AF_INET;
  	ad.sin_addr.s_addr=inet_addr("127.0.0.1");
  	ad.sin_prot=htons(11234);
  	
  	connect(sp, (struct sockaddr *) &ad, sizeof(ad));
  	
  	read(sp, buf, 5);
  	printf("%s", buf);
  	
  	close(sp);
  	exit(0);
  }
  ```

  - 클라이언트는 소켓을 생성한 후 `connect()`를 사용하여 서버와의 접속을 시도
  - 접속 이후에는 `read()` 혹은 `write()` 작업을 하고, 작업이 끝나면 소켓 기술자를 닫고 종료



- 서버 코드

  ```c
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <netdb.h>
  
  void main() {
  	int sp, sa;
  	struct sockaddr_in ad;
  	
  	memset(&ad, 0, sizeof(ad));
  	ad.sin_family=AF_INET;
  	ad.sin_addr.s_addr=htonl(INADDR_ANY);
  	ad.sin_prot=htons(11234);
  	
      sp=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  	bind(sp, (struct sockaddr *) &ad, sizeof(ad));
      
      listen(sp, 10);
  	while(1) {
          sa=accept(sp, 0, 0);
          write(sa, "Test", 5);
          close(sa);
      }
  }
  ```

  - 서버는 소켓을 생성한 후 `bind()`를 사용하여 생성한 소켓을 특정 포트에 등록
    - 여러 컴퓨터는 IP로 구분하고, 한 컴퓨터의 여러 프로세스는 포트 번호로 구분
  - `bind()`로 소켓이 정상적으로 등록되면 `listen()`을 실행하여 클라이언트를 받을 준비를 함
  - `accept()`는 클라이언트의 `connect()`, 즉 연결 요청을 기다리다가 여러 명의 클라이언트가 동시에 `connect()`를 하는 경우 그중 하나를 골라 작업을 시작함
