# Chapter11 파일 시스템

[[_TOC_]]

## 1. 파일과 파일 시스템

### 1. 파일 시스템의 개요

#### 1.1 파일 시스템의 개념

- **파일 시스템**
  - 파일을 보관하고 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 맡기는 시스템
    - 사용자가 직접 파일을 보관하거나 접근하지 못하게 함
  - 파일 관리자는 파일 테이블을 사용하여 파일을 관리(파일의 생성, 수정 , 삭제 등을 수행)
    - 또한 사용자가 파일을 사용하고자 할 때 읽기, 쓰기, 실행과 같은 다양한 접근 방법을 제공
    - 사용자가 파일에 접근하려면 파일 관리자로부터 파일에 접근할 수 있는 권한을 획득해야 함
      - 이러한 파일 접근 권한을 **파일 디스크립터**라고 함



#### 1.2 파일 시스템의 기능

- 파일 시스템의 기능

  | 기능           | 설명                                                         |
  | -------------- | ------------------------------------------------------------ |
  | 파일 구성      | 사용자의 요구에 따라 파일과 디렉터리를 만듬                  |
  | 파일 관리      | 파일 생성, 수정, 삭제 등의 관리를 하고, 수시로 조각 모음을 하여 사용자가 파일에 빨리 접근할 수 있도록 함 |
  | 접근 권한 관리 | 다른 사용자로부터 파일을 보호하기 위해 접근 권한을 관리      |
  | 접근 방법 제공 | 파일을 읽고 쓰고 실행할 수 있도록 사용자에게 접근 방법을 제공 |
  | 무결성 보장    | 파일의 내용이 손산되지 않도록 무결성을 보장                  |
  | 백업과 복구    | 사고로부터 파일을 보호하기 위해 백업과 복구 작업             |
  | 암호화         | 파일을 암호화하여 악의적인 접근으로부터 파일을 보호          |



#### 1.3 블록과 파일 테이블

- **블록**
  - 저장장치에서 사용하는 가장 작은 단위로 한 블록에 주소 하나가 할당
    - 하드디스크의 물리 구조상 가장 작은 단위는 섹터
    - 그러나 섹터마다 주소를 부여하면 너무 많은 양의 주소가 필요하므로 여러 섹터를 묶어 블록을 만듬
  - 블록의 크기가 작은 경우
    - 내부 단편화 현상이 줄어들지만, 파일 입출력 속도가 느려짐
    - 따라서 큰 파일을 많이 사용할 때는 블록 크기를 크게 잡는 것이 좋음
  - 포맷 방식에 따라 블록의 크기가 다양해짐
    - 직접 설정할 수도 있고 시스템 설정을 따라갈 수도 있음



- **파일 테이블**
  - 포맷을 하면 각 블록에 번호가 매겨지고 파일 테이블에는 파일이 어떤 블록에 있는지 명시됨



### 2. 파일 분류와 확장자

- 파일
  - 논리적인 데이터의 집합으로 제2저장장치에 저장됨
    - 모든 파일은 0과 1의 비트 패턴으로 이루어짐
  - 파일의 구성(운영체제의 입장에서)
    - **실행 파일**
      - 운영체제가 메모리로 가져와 CPU를 이용하여 작업하는 파일
      - 즉 사용자의 요청으로 프로세스 된 파일
    - **데이터 파일**
      - 실행 파일이 작업하는 데 필요한 데이터를 모아놓은 파일
        - 이미지 뷰어의 사진 파일, 뮤직 플레이어의 음악 파일, 워드의 문서 파일 등
      - 스스로 프로세스가 될 수 없으므로 보관 및 전송만 할 뿐 특별하게 다루지 않음



- 파일의 분류와 확장자

  | 파일            | 확장자                   | 설명                                |
  | --------------- | ------------------------ | ----------------------------------- |
  | 실행 파일       | exe, com                 | 유닉스에는 실행 파일 확장자가 없음  |
  | 소스코드 파일   | c, cpp, pas, a, java     | 다양한 소스코드의 확장자            |
  | 라이브러리 파일 | lib, a, dll              | 소스코드를 위한 라이브러리의 확장자 |
  | 배치 파일       | bat, sh, sch             | 초기 배치 파일의 확장자             |
  | 문서 파일       | txt, doc, hwp, pdf, ps   | 문서 데이터 파일의 확장자           |
  | 동영상 파일     | avi, asf, mkv, mov, rmv  | 동영상 데이터 파일의 확장자         |
  | 음악 파일       | wav, mp3, ogg, flc, aac  | 음악 데이터 파일의 확장자           |
  | 이미지 파일     | bmp, gif, jpg, tiff, png | 이미지 데이터 파일의 확장자         |
  | 압축 파일       | rar, zip, arc, al        | 압축 파일의 확장자                  |



### 3. 파일 이름과 연결 프로그램

- 윈도우에서 더블클릭에 따른 반응
  - 실행 파일
    - 프로세스가 생성되어 실행
  - 데이터 파일
    - 해당 파일을 사용하는 응용 프로그램이 실행
    - 데이터 파일 자체가 실행되는 것이 아님



### 4. 파일 속성

- 파일 속성의 종류

  | 속성          | 특징             |
  | ------------- | ---------------- |
  | name          | 파일의 이름      |
  | type          | 파일의 종류      |
  | size          | 파일의 크기      |
  | time          | 파일의 접근 시간 |
  | location      | 파일의 위치      |
  | accessibility | 파일의 접근 권한 |
  | owner         | 파일의 소유자    |

  - **name**: 확장자를 포함한 전체 이름
  - **type**: 실행 파일, 동영상 파일, 사진 파일, 음악 파일과 같이 확장자로 구분
  - **size**: 파일의 용량
  - **time**: 만든 시간, 변경 시간, 최근 파일을 열어본 시간 등
  - **location**: 파일의 위치(파일의 위치가 다르면 서로 다른 파일로 여김) 
    - 같은 위치에 name이 같은 거  있을 수 없음
  - **accessibility**
    - 윈도우에서는 읽기, 쓰기, 숨김 파일 등
    - 유닉스에서는 소유자, 그룹, 제삼자에 따라 다르게 설정 가능
  - **owner**
    - 윈도우에서는 소유자의 개념이 없지만, 유닉스에서는 명확하게 구분하여 사용



- **헤더**
  - **파일 헤더**
    - 파일 테이블에서 관리하며 파일의 이름, 종류, 크기, 시간, 접근 권한 등 일반적인 내용이 담김
    - 파일이 저장장치의 몇 번째 블록에 있는지에 대한 정보도 포함
  - **고유 헤더**
    - 파일의 버전 번호, 크기, 특수 정보 등 응용 프로그램이 필요로 하는 정보가 담김
    - 데이터 파일에 고유 헤더가 따로 달려 있음
    - 파일의 복구에서 유용하게 사용
      - 빠른 포맷, 휴지통에 버리는 등의 행동은 파일 테이블만 지우는 것
      - 따라서 데이터 파일의 고유 헤더는 저장장치에 남아 있어 복구가 가능함



### 5. 파일 작업의 유형

- **파일 작업**(**파일 연산**)
  - 파일을 지우거나 이름을 바꾸는 것(파일을 변경하는 것)
  - 파일 자체를 변경하는 것과 파일 내용을 변경하는 것으로 구분할 수 있음



#### 5.1 파일 자체를 변경하는 작업

- 파일 자체를 변경하는 작업

  | 작업   | 설명               | 작업   | 설명               |
  | ------ | ------------------ | ------ | ------------------ |
  | open   | 파일을 열음        | copy   | 파일을 복사        |
  | close  | 파일을 닫음        | rename | 파일의 이름을 변경 |
  | create | 새로운 파일을 생성 | list   | 파일을 나열        |
  | remove | 파일을 이동        | search | 파일을 찾음        |

  - **list**
    - 디렉터리에 있는 파일의 이름을 보여주는 것(크기, 만든 날짜 등도 같이 나열됨)
  - **search**
    - 여러 디렉터리에서 파일을 찾는 것(이름순, 크기순, 만든 날짜 순 등으로 검색 가능)
    - ab로 시작하는 모든 파일을 찾고 싶은 경우 => ab*
    - ab로 시작하되 한 글자만 더 있는 파일을 찾고 싶은 경우 => ab?

#### 5.2 파일 내용을 변경하는 작업

- 파일의 내용을 변경하는 작업

  | 작업     | 설명               | 작업     | 설명                      |
  | -------- | ------------------ | -------- | ------------------------- |
  | open()   | 파일을 열음        | write()  | 파일에 새로운 내용을 씀   |
  | create() | 새로운 파일을 생성 | update() | 파일 내용 중 일부를 변경  |
  | close()  | 파일을 닫음        | insert() | 파일에 새로운 내용을 추가 |
  | read()   | 파일 내용을 읽음   | delete() | 파일 내용 중 일부를 지움  |

  - `open()`, `create()`를 통해 운영체제로부터 이용 권한을 획득
    - 권한을 획득한 이후 `write()`, `update()`, `insert()` 등의 작업이 가능
  - `close()`를 통해 운영체제에 작업이 끝났음을 알리고 권한을 반납



### 6. 파일 구조

- 파일은 데이터 덩어리로 이 구조를 어떻게 구성하냐에 따라 순차 파일 구조, 인덱스 파일 구조, 직접 파일 구조로 나뉨



#### 6.1 순차 파일 구조

- **순차 파일 구조**
  - 일반 파일의 구조로 파일 내용이 긴 줄로 늘어선 형태
    - 파일의 내용에 접근하기 위해서는 앞에서 또는 뒤에서 차례대로 접근(**순차 접근**)
    - 초기의 컴퓨터는 카세트테이프(순차 파일의 구조)를 저장장치로 이용함
  - 사용 과정
    - 사용자가 파일을 사용하려면 `open()`, `create()`로 권한을 얻어야 함
    - 운영체제는 권한을 주면서 파일 디스크립터를 사용자에게 줌
      - 파일 디스크립터는 파일의 맨 앞에 위치
    - `read()`, `write()`  명령을 내리면 파일 디스크립터가 앞으로 전진하며 작업
      - 만약 특정 위치로 옮겨야 한다면 `lseek()`를 사용
  - **장점**
    - 순서대로 기록되므로 저장 공간에 낭비가 없음
    - 구조가 단순하여 테이프, 플로피디스크 등 저장장치에 적용 가능
    - 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 작동
  - **단점**
    - 새로운 데이터를 삽입하거나 삭제할 때 시간이 오래 걸림
      - 즉 데이터 변경이 잦은 경우 적합하지 못함
    - 특정 데이터를 이동할 때 직접 접근이 어렵기 때문에 앞에서부터 순서대로 움직여야 함
      - 즉 데이터 검색에는 적합하지 못함



#### 6.2 인덱스 파일 구조

- **인덱스 파일 구조**
  - 순차 파일 구조에 인덱스 테이블을 추가하여 **순차 접근**과 **직접 접근**이 가능
    - **인덱스 순차 접근**: 인덱스를 이용한 접근
    - 인덱스 순차 접근으로 구성된 파일을 **ISAM**이라고 함
  - 현대의 파일 시스템의 파일 구조



#### 6.3 직접 파일 구조

- **직접 파일 구조**
  - 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조
  - 예를 들어 키를 학번으로 대학생들의 정보를 저장하려는 경우
    - 학번을 10으로 나눈 나머지로 주소를 바꿈
      - 끝자리가 0인 학생은 0번 저장장치, 1인 학생은 1번 저장장치 등
    - 이렇게 특정 함수를 이용하여 직접 접근이 가능한 구조가 직접 파일 구조
      - 이때 사용하는 함수를 **해시 함수**라고 함
  - **장점**
    - 해시 함수를 이용하여 주소를 변환하기 때문에 매우 빠름
  - **단점**
    - 전체 데이터가 고르게 저장될 수 있는 해시 함수를 찾아야 함
    - 해시 함수를 잘 찾았더라도 저장 공간이 낭비될 수 있음



## 2. 디렉터리 구조

### 1. 디렉터리의 개념

- **디렉터리**
  - 관련 있는 파일을 하나로 모아놓은 곳
    - 디렉터리는 한 개 이상의 자식 디렉터리를 가질 수 있고, 1개 이상의 파일을 가질 수 있음
    - 즉 디렉터리는 여러 층으로 구성될 수 있음
      - **루트 디렉터리**: 최상위에 있는 디렉터리
    - 여기서 슬래쉬(/)는 루트 디렉터리를 의미하거나 디렉터리와 디렉터리의 구분자로 사용됨(유닉스)



### 2. 디렉터리 파일

- **디렉터리**
  - 디렉터리도 파일(즉 일반 파일에는 데이터가, 디렉터리에는 파일 정보가 담기는 것)
    - 일반 파일과 마찬가지로 헤더를 가짐(헤더에는 디렉터리 이름, 만든 시간 등이 기록)



### 3. 경로

- **경로**
  - 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보
    - **절대 경로**: 루트 디렉터리를 기준으로 파일의 위치를 나타내는 방식
      - ex - `/program/dad/exm.c`
    - **상대 경로**: 현재 있는 위치를 기준으로 파일의 위치를 표시하는 방식
      - ex - `../user/exm.c`
  - 디렉터리를 이동할 떄는 `cd` 명령을 사용



### 4. 디렉터리 구조

- **1단계 디렉터리 구조**
  - 초기 파일 시스템의 디텍터리 구조로 루트 디렉터리에 새로운 디렉터리는 만들 수 있지만, 디렉터리 안에 자식 디렉터리를 만들 수 없음
  - 매우 단순하지만 파일이 많아지면 불편



- **다단계 디렉터리 구조**
  - 단계 확장의 제약이 없고 디렉터리에 파일과 디렉터리를 둘 다 저장할 수 있는 구조
  - 다단계 디렉터리 구조는 순환이 있을 수 있음(이 경우 트리 구조 => 그래프 구조)
    - 기본적인 구조는 트리이나 디렉터리와 디렉터리를 연결하는 링크가 있기 때문
    - ex - 윈도우의 바로가기, 유닉스의 `ln` 명령어(바로가기)



### 5. 마운트

- 파티션

  - 디스크의 논리적인 분할
  - 초기 윈도우 개발 시 윈도우 FAT16 파일 시스템의 최대 크기가 32GB였기에 파티션으로 나누어 써야했음
    - FAT의 최대 크기 문제를 해결한 파일 시스템이 **NTFS**

  

- **마운트**

  - 여러 개의 파티션을 통합하는 명령어
  - 유닉스의 경우 서버용으로 만들어진 운영체제이므로 파일 테이블의 크기에 제한이 없고, 하나의 파일 테이블로 여러 개의 디스크 혹은 파티션을 통합하여 관리할 수 있음
    - 외부 저장장치(USB, CD-ROM 등)도 파티션에 붙일 수 있음
  - **마운트 연결 지점**(`/mnt`)
    - 마운트를 사용하여 디렉터리를 이동할 때 마운트 연결 지점을 이용함
    - 즉 사용자에게는 하나의 파티션으로 보이므로 몇 개의 파티션이 합쳐져 있는지 모름
  - **마운트 해제**
    - 파티션 분리도 가능



## 3. 디스크 파일 할당

### 1. 연속 할당과 불연속 할당

- 파일 시스템은 파일의 이름과 해당 파일이 시작하는 블록 주소를 가진 파일 테이블을 관리
  - 파일 테이블은 파티션당 하나씩 존재하며 각 파티션의 맨 앞부분에 위치



- 블록 연결 방식에 따른 구분
  - **연속 할당**
    - 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 방식
    - 파일의 시작 블록만 알면 전체 파일을 찾을 수 있음
    - 파일을 저장하거나 삭제하면 빈 공간이 생기는데, 디스크에 남은 공간 중 파일의 크기와 맞는 연속된 공간이 없으면 연속 할당이 불가해짐 => 사용 안함
  - **불연속 할당**
    - 비어 있는 블록에 데이터를 분산하여 저장하고 이에 관한 정보를 파일 시스템이 관리하는 방식
    - 대표적인 방법으로는 연결 리스트를 이용한 **연결 할당**과 인덱스를 이용한 **인덱스 할당**이 존재



#### 1.1 연결 할당

- **연결 할당**(**체인 할당**)
  - 파일에 속한 데이터를 연결 리스트로 관리하는 방식
  - 파일 테이블에는 블록에 대한 정보만 저장하고, 나머지 데이터는 시작 블록부터 연결하여 저장
    - 파일의 맨 끝에 해당하는 블록에는 링크 대신 null 삽입
  - 대표적으로 윈도우의 FAT
    - FAT은 버전에 따라 FAT12, FAT16 등이 존재
    - FAT 다음의 숫자는 파일 할당 주소의 최대 크기를 나타냄(FAT16 => 2\*\*16)
  - **단점**
    - 하나의 파티션이 사용할 수 있는 디스크의 용량이 테이블의 주소 크기로 제한됨
      - 즉 FAT16의 경우 16bit를 주소로 사용하므로 지원하는 최대 파티션의 크기가 32GB임
      - 이러한 이유로 현재 윈도우 운영체제는 64bit 주소를 지원하는 NTFS 파일 시스템을 사용



### 1.2 인덱스 할당

- **인덱스 할당**
  - 테이블의 블록 포인트가 데이터 블록을 연결하는 것이 아닌, 데이터의 인덱스를 담고 있는 인덱스 블록을 연결
    - 인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관(파일의 끝은 -1로 표시)
  - 테이블이 꽉 차서 더 이상 데이터를 연결할 수 없을 때는 인덱스 블록을 연결하는 **간접 인덱스 블록**을 만들면 테이블을 무한히 확장 가능
    - 이 방식으로 연결 할당의 용량 제한의 단점을 개선한 것
    - 대표적으로 유닉스의 **I-node**가 이러한 방식으로 구조는 다음과 같음
      - **파일 제어 블록**
        - 파일 소유자와 각종 속성을 나타냄
        - 모든 권한의 정보를 나타내므로 **슈퍼블록**이라고도 함
      - **블록 포인터**
        - 데이터가 있는 블록의 위치를 직접 연결하는 포인터
      - **간접 포인터**
        - 파일 크기가 커서 블록 포인터가 다 차면 인덱스 블록을 생성한 후 간접 포인터를 생성하여 인덱스 블록을 연결함
          - 크기가 작은 파일은 직접 연결된 블록 포인터로 빠르게 접근 가능
      - **이중/삼중 간접 포인터**
        - 파일의 크기가 커서 인덱스 블록 하나로도 연결이 안되는 경우 이중 간접 포인터를 사용
          - 이보다 더 필요한 경우에 삼중 간접 포인터를 사용
          - 보통 인덱스 블록에는 256개의 블록을 저장 가능
            - 즉 삼중 간접 포인터는 256\*\*3개의 인덱스 블록을 연결 가능한 것
      - I-node 특징 요약
        - 파일의 크기가 작으면 블록을 직접 빠르게 연결하여 접근
        - 파일의 크기가 크면 인덱스 블록과 이를 연결하는 간접 포인터를 이용하여 확장



### 2. 디스크의 빈 공간 관리

- **빈 공간 리스트**
  - 파일 시스템이 빈 블록의 정보만 모아놓은 리스트
    - 파일을 저장할 때마다 모든 테이블을 뒤져서 빈 공간을 찾는 것은 비효율적
  - 블록의 내용을 지우면 시간이 오래 걸리므로 빈 공간 리스트에 있는 블록은 내용은 그대로 가지고 있고 나중에 다시 사용될 때 덮어씀
    - 즉 빈 공간 리스트에 있더라도 복구할 수 있음
  - 리스트에 있는 맨 앞의 블럭(먼저 들어온)부터 사용함
    - 나중에 들어온 것부터 사용하면 특정 블록만 계속 사용하게 될 수 있음



- 파일 시스템 오류 복구
  - 갑작스러운 전원 차단 등으로 인해 데이터를 저장했으나 블록 포인터가 사라져 데이터가 없어진 것처럼 보이는 경우나 디스크의 빈 공간이 빈 공간 리스트에 저장되지 않을 수 있음
  - 운영체제는 이러한 파일 시스템의 오류를 수정하는 명령어를 가지고 있음
    - 윈도우 => 디스크 오류 검사(`chkdsk`)
    - 유닉스 => `fsck`



## 4. [심화학습] 유닉스 파일의 특징

### 1. 유닉스 실행 파일

- 유닉스에서는 실행 파일을 확장자(ex - com, exe)로 구분하지 않고 접근 방법으로 구분



- 유닉스 파일 접근 패턴
  - `-rwxrw-r--`
    - 맨 앞자리는 파일의 종류를 의미
      - `-`: 일반 파일 | `d`: 디렉터리 | `l`: 링크
        - 여기서 링크는 윈도우의 바로가기와 같은 기능
    - 첫 자리를 제외한 9자리는 `rwx`라는 세 덩어리로 구성
      - `r`: read 권한 | `w`: write 권한 | `e`: execute 권한
      - 첫 번째 덩어리 => **파일의 소유자 권한**
        - 여기서는 소유자가 읽기, 쓰기, 실행 가능
      - 두 번째 덩어리 => **소유자가 속한 그룹의 권한**
        - 여기서는 소유자가 속한 그룹은 읽기와 쓰기가 가능
      - 세 번재 덩어리 => **제삼자의 권한**
        - 여기서는 제삼자가 읽기 가능
  - `chmod`
    - 접근 패턴을 변경하는 명령어
    - 여기서 read = 4, write = 2, execute = 1로 이용하고 싶은 권한을 다 더하면 됨
    - 예를 들어 chmod764라고 하면 위의 `-rwxrw-r--`로 변경하라는 의미
