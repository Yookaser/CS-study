# Chapter4 CPU 스케줄링

[[_TOC_]]

## 1. 스케줄링의 개요

- CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 함



### 1. 식당 관리자의 스케줄링

- 대부분의 식당 구조상 요리사는 홀의 상태를 알기 어려움 => 식당 관리자가 홀을 관리
  - 예약 관리, 좌석 관리, 주문 관리, 주문 순서 관리, 손님 요청 관리 등



### 2. 스케줄링 단계

- 주문과 관련한 식당 관리자 역할

  1. 좌석 관리
     - 손님이 많은 경우 자리를 늘리면 이득이나 손님을 너무 많이 받으면 주문의 소화를 못할 수 있음
       - 또한, 예약 손님에게 자리를 배정하지 못할 수 있음
     - 따라서 전체 좌석 수, 실시간 좌석 배정, 여유 좌석 배분 등의 **큰 틀**에서 좌석을 관리함
  2. 조리 순서를 관리
     - 자리를 배정받은 손님을 대상으로 이뤄지는 **작은  틀**에서 관리
     - 요리가 나가는 순서와 속도를 관리함

  - 이처럼 CPU 스케줄러도 범주를 나누어 스케줄링함



#### 2.1 고수준 스케줄링

- 고수준 스케줄링
  - 가장 큰 틀에서 이루어지며 장기 스케줄링, 작업 스케줄링이라고도 함
  - 역할
    - 시스템 내의 전체 작업 수를 조절(작업 => 운영체제에서 다루는 가장 큰 단위로 1개 또는 여러 프로세스로 구성됨)
    - 어떤 작업을 시스템이 받아들일지 거부할지를 결정
      - 즉, 작업이 오면 시스템의 상황을 고려하여 작업을 승인할지 거부할지 결정(승인 스케줄링)



#### 2.2 저수준 스케줄링

- 저수준 스케줄링
  - 가장 작은 단위의 스케줄링이며 단기 스케줄링이라고도 함
  - 역할
    - 어떤 프로세스에 CPU를 할당할지 결정(실행 => 대기)
    - 어떤 프로세스를 대기 상태로 보낼지 결정(대기 => 실행)



#### 2.3 중간 수준 스케줄링

- 중간 수준 스케줄링
  - 고수준과 저수준 스케줄링 사이에서 일어나는 스케줄링
  - 고수준 스케줄링이 프로세스를 활성화한 다음에도 여러 상황으로 시스템에 과부하가 걸릴 수 있기 때문에 중간 수준 스케줄링이 필요
  - 역할
    - **중지**와 **활성화**로 전체 시스템에 활성화된 프로세스 수를 조절하여 과부하를 방지
      - 즉, 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원
        - 이는 **보류 상태**에 해당하고, 저수준 스케줄링이랑 원만하게 이루어지도록 완충하는 역할



#### 2.4 스케줄링의 단계 정리

- 고수준 스케줄링
  - 전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정
  - 결정에 따라 전체 프로세스 수가 결정되는데 이를 멀티프로그래밍 정도라 함
  - 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용



- 중간 수준 스케줄링
  - 프로세스가 활성화된 이후 시스템의 과부하를 방지
  - 중지와 활성화를 통해 프로세스를 보류 상태와 실행 상태로 옮김



- 저수준 스케줄링
  - 준비 상태의 프로세스를 실행 상태로 옮기거나 대기 상태로 보내기도 함
  - 타임 아웃으로 준비 상태로 돌려보내기도 함
  - 어떤 기준으로 타임 슬라이스를 정할지 등



### 3. 스케줄링의 목적

- CPU 스케줄링의 목적
  - 원래 목적은 모든 프로세스가 공평하게 작업하도록 하는 것
    - 공평성을 유지하면서도 안정적으로 작동해야 함
      - 즉, 특정 프로세스가 시스템 자원을 독점하거나 파괴하는 것을 막기 위해 중요도에 다라 우선순위 배정
    - 시스템 자원을 효율적으로 배분하여 전체적인 시스템 성능을 높여야 함
    - 프로세스 개수가 증가해도 성능에 갑작스러운 변화가 없어야 함(확장성)

|      목적      | 설명                                                         |
| :------------: | ------------------------------------------------------------ |
|     공평성     | 모든 프로세스가 자원을 공평하게 배정받고, 자원 배정 과정에서 특정 프로세스가 배제되서는 안됨 |
|     효율성     | 시스템 자원이 유휴 시간이 없이 사용되게 스케줄링하고, 유후 자원을 사용하려면 프로세스에는 우선권을 부여해야 함 |
|     안정성     | 우선순위를 사용하여 중요 프로세스가 먼저 작동하게 배정하여 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호 |
|     확장성     | 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조취하고 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 함 |
| 반응 시간 보장 | 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응 |
| 무한 연기 방지 | 특정 프로세스의 작업이 무한히 연기되어서는 안됨              |



## 2. 스케줄링 시 고려 사항

### 1. 선점형 스케줄링과 비선점형 스케줄링

- **선점형 스케줄링**
  - 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
  - 대표적으로 인터럽트가 있음
  - **장점**
    - 하나의 프로세스가 CPU를 독점할 수 없기 때문에 빠른 응답 시간을 필요로 하는 시스템에 적합
      - ex) 시분할 시스템, 대화형 시스템
  - **단점**
    - 문맥 교환과 같은 부가적인 작업으로 인해 낭비가 발생
- **비선점형 스케줄링**
  - 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 방식
  - **장점**
    - 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음
  - **단점**
    - CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 프로세스가 오랫동안 기다리게 되어 전체 시스템 효율이 떨어질 수 있음
      - ex) 일괄 작업 시스템



### 2. 프로세스 우선순위

- 우선순위
  - 우선순위가 없다는 것은 중요도가 모두 같다는 것 => 하나의 큐
  - 우선순위가 높다는 것은 더 빨리 자주 실행된다는 것
  - 시스템에 따라 숫자가 큰 것이 우선순위가 높은 것도 있고 반대도 있음



- 프로세스는 커널 프로세스와 일반 프로세스로 나뉨
  - 커널 프로세스는 일반 프로세스 보다 우선순위가 높음
    - 커널과 일반 각각 내부에서도 우선순위의 차이가 있음



### 3. CPU 집중 프로세스와 입출력 집중 프로세스

- **CPU 버스트**와 **입출력 버스트**
  - CPU 버스트: CPU를 할당받아 실행하는 작업
  - 입출력 버스트: 입출력 작업을 하는 작업
  - 실제 작업이 일어나는 것은 실행 상태와 대기 상태만 있으므로 



- **CPU 집중 프로세스**와 **입출력 집중 프로세스**
  - CPU 집중 프로세스
    - 수학 연산과 같이 CPU를 많이 사용하는 프로세스를 의미
    - 즉, CPU 버스트가 많은 프로세스
  - 입출력 집중 프로세스
    - 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스를 의미
    - 즉, 입출력 버스트가 많은 프로세스
  - 두 프로세스가 함께 있다면 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적
    - 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨져 다른 프로세스가 CPU를 사용할 수 있기 때문
    - 이렇게 먼저 들어가는 것을 **사이클 훔치지**라고 함



### 4. 전면 프로세스와 후면 프로세스

- **전면 프로세스**와 **후면 프로세스**
  - 전면 프로세스
    - GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스를 의미하며 현재 입력과 출력을 사용하는 프로세스(사용자와 상호작용이 가능하여 상호작용 프로세스라고도 함)
  - 후면 프로세스
    - 사용자와 상호작용이 없는 프로세스(사용자 입력이 없이 작동하므로 일괄 작업 프로세스라고도 함)
  - 통상 전면 프로세스가 후면 프로세스보다 CPU를 할당받을 확률이 높음



### 5. 정리

|    우선순위 높음     |   우선순위 낮음    |
| :------------------: | :----------------: |
|    커널 프로세스     |   일반 프로세스    |
|    전면 프로세스     |   후면 프로세스    |
|   대화형 프로세스    | 일괄 처리 프로세스 |
| 입출력 집중 프로세스 | CPU 집중 프로세스  |



## 3. 다중 큐

#### 1. 준비 상태의 다중 큐

- 다중 큐가 필요한 이유
  - CPU 스케줄러가 모든 프로세스 제어 블록을 검색하여 우선순위가 가장 높은 프로세스를 찾는 것은 비효율적
  - 따라서 프로세스 우선순위에 따라 여러 개의 큐를 만들면 효율적



- 프로세스 우선순위 배정 방식
  - **고정 우선순위 방식**
    - 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
    - 구현은 쉬우나 시스템 변화에 대응하기 어려워 작업 효율이 떨어짐
  - **변동 우선순위 방식**
    - 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식
    - 구현은 어려우나 시스템의 효율성은 높음
    - **반전 우선순위**
      - 낮은 우선순위를 높은 우선순위로 바꾸는 것



### 2. 대기 상태의 다중 큐

- 다중 큐가 필요한 이유
  - 입출력이 완료되기를 기다리는 프로세스가 모여 있는 곳으로 다양한 입출력장치가 있기 때문에 한곳에 모아놓으면 관리가 불편
  - 따라서 같은 입출력을 요구한 프로세스끼리 모아 놓으면 효율적



- 준비 상태의 다중큐와의 차이
  - 준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당하지만, 대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮김
    - 즉, 입출력이 동시에 끝날 경우 여러 인터럽트가 한꺼번에 처리
      - 동시의 인터럽트를 처리하기 위해 **인터럽트 벡터**라는 자료 구조를 사용
        - 인터럽트 벡터는 동시에 완료된 입출력 정보와 처리 방법이 담겨 있음
        - 이 정보에 따라 완료된 프로세스 제어 블록은 모두 준비 상태로 이동
  - 대기 큐의 프로세스 제어 블록은 삽입된 순서대로 처리하나, 일부는 나중에 들어온 프로세스 제어 블록이 먼저 준비 큐로 옮겨가기도 함
    - 입출력 장치가 CPU나 메모리보다 느리므로 작업 속도를 높이기 위해 작업 순서를 바꾼 경우



## 4. 스케줄링 알고리즘

| 구분              | 종류                                          |
| ----------------- | --------------------------------------------- |
| 비선점형 알고리즘 | FCFS, SJF, HRN                                |
| 선점형 알고리즘   | 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 |
| 둘 다 가능        | 우선순위                                      |



### 1. 스케줄링 알고리즘의 선택 기준

- 평가 기준
  - **CPU 사용률**
    - 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방식
      - 이상적으로 100%이나 여러 가지 이유로 90% 못 미침
  - **처리량**
    - 단위 시간당 작업을 마친 프로세스의 수
  - **대기 시간**
    - 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
  - **응답 시간**
    - 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
  - **실행 시간**
    - 프로세스 작업이 시작된 후 종료되기까지의 시간
  - **반환 시간**
    - 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
    - 대기 시간과 실행 시간의 합
  - CPU 알고리즘의 효율성을 평가할 때 사용률과 처리량은 계산하기 힘드므로 주로 대기 시간, 응답 시간, 반환 시간을 계산함



### 2. FCFS 스케줄링

#### 2.1 FCFS 스케줄링의 동작 방식

- **FCFS**(선입선출 스케줄링)
  - 준비 큐에 도착한 순서대로 CPU에 할당하는 비선점형 방식
  - 모든 프로세스의 우선순위가 동일한 것



#### 2.2 FCFS 스케줄링의 성능

#### 2.3 FCFS 스케줄링 평가

- **단점**
  - **콘보이 효과**(호위 효과)
    - 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들이 대기하여 시스템 효율이 떨어지는 문제
  - 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아짐
    - 시분할 시스템에서는 대기 상태로 처리할 수 있으나 일괄 작업 시스템에서는 안되므로 효율 떨어짐



### 3. SJF 스케줄링

#### 3.1 SJF 스케줄링의 동작 방식

- **SJF**(최단 작업 우선 스케줄링, SPF | 최단 프로세스 우선 스케줄링)
  - 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU에 할당하는 비선점형 방식
  - 콘보이 효과를 완화하여 시스템 효율을 높이려는 것



#### 3.2 SJF 스케줄링의 성능

#### 3.3 SJF 스케줄링 평가

- **장점**
  - 작은 작업을 먼저 실행하므로 시스템 효율성이 좋아짐
    - 큰 작업으로 인해 작은 작업이 지연되는 FCFS보다 평균 대기 시간이 줄어들기 때문



- **단점**

  1. 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어려움
     - 현대 프로세스는 사용자와 상호작용이 빈번하므로 프로그램 종료 시간을 파악하기 힘듬
       - 즉, 프로세스의 작업 길이를 예측하기 힘들기 때문에 사용이 어려움

  2. 공평하지 못함
     - **아사 현상**(무한 봉쇄 현상)
       - 작업 시간이 길다는 이유 때문에 프로세스의 우선순위가 계속 뒤로 밀리는 현상



- 단점 극복의 수단
  1. 프로세스가 자신의 작업 시간을 운영체제에 알려주는 방법
     - 하지만 프로세스가 자신의 작업 시간을 알기 어렵고, 악의적 프로세스가 작업 시간을 속일 수 있음
  2. 에이징 적용
     - 에이징은 프로세스가 양보할 수 있는 상한선을 정하는 것
     - 하지만 어떤 기준으로 에이징을 정할 것인가에 문제가 있음



### 4. HRN 스케줄링

#### 4.1 HRN 스케줄링의 동작 방식

- **HRN**(최고 응답률 우선 스케줄링)
  - SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘
  - 우선순위 = (대기 시간 + CPU 사용 시간) / (CPU 사용 시간)
    - 즉, 스케줄링 방식에 에이징을 고려한 방법(우선순위 숫자가 클수록 우선순위 높음)



#### 4.2 HRN 스케줄링의 평가

- 아사 현상을 완화했지만 여전히 공평성에 위배되므로 많이 사용되지 않음



### 5, 라운드 로빈 스케줄링

#### 5.1 라운드 로빈 스케줄링의 동작 방식

- **라운드 로빈**(순환 순서 방식)
  - 프로세스가 할당 받은 시간(타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
  - 선점형 알고리즘 중 가장 단순하고 대표적인 방식
  - FCFS와의 차이는CPU를 사용할 수 있는 최대 시간이 있다는 점



#### 5.2 라운드 로빈 스케줄링의 성능

- 프로세스가 일정 시간 동안 사용한 후 다른 프로세스에게 주어야 하므로 긴 작업을 무작정 기다리던 콘베이 효과가 줄어듬



#### 5.3 타임 슬라이스의 크기와 문맥 교환

- FCFS와 라운드 로빈
  - 어떤 스케줄링이 더 좋다고 말할 수 없음 => 상황에 따라 달라짐
  - 다만, 평균 대기 시간 계산이 같다면 라운드 로빈이 더 비효율적임
    - 문맥 교환의 시간이 있기 때문
  - 효과적인 라운드 로빈을 위해서는 타임 슬라이스를 적절히 설정해야 함
    - 타임 슬라이스 가 큰 경우
      - FCFS 스케줄링과 다를 게 없어짐(무한대인 경우 완전히 같음)
    - 타임 슬라이스가 작은 경우
      - 매우 작다면 사용자 입장에서는 동시에 실행되는 것처럼 보임
      - 하지만 문맥 교환이 너무 자주 일어나 문맥 교환 시간이 작업 시간보다 상대적으로 커져 비효율
    - 따라서 적당한 크기가 필요하고 유닉스의 경우 대략 100밀리초(10~200 유동적)



### 6. SRT 우선 스케줄링

#### 6.1 SRT 스케줄링의 동작 방식

- **SRT**(최소 잔류 시간 우선 스케줄링)
  - SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식(SJF의 선점형 버전)
  - 기본적으로 라운드 로빈 스케줄링을 사용하나, CPU를 선택할 때 남은 작업 시간이 가장 적은 프로세스를 선택함



#### 6.2 SRT 스케줄링 성능

#### 6.3 SRT 스케줄링 평가

- SJF와의 비교
  - SRT는 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야하므로 SJF에 없는 작업이 추가됨
  - SJF와 마찬가지로 프로세스 종료 시간 예측이 어렵고 아사 현상이 일어나 잘 사용하지 않음



### 7. 우선순위 스케줄링

#### 7.1 우선순위 스케줄링의 동작 방식

- **우선순위**
  - 프로세스의 우선순위를 반영한 스케줄링 알고리즘으로 선점형과 비선점형에 모두 적용 가능
    - **SJF 스케줄링**, **HRN 스케줄링**, **SRT 스케줄링** 등
  - 고정 우선순위와 변동 우선순위로 나뉨
    - **고정 우선순위 알고리즘**
      - 한 번 우선순위를 부여받으면 종료될 때까지 고정됨
      - 구현은 쉬우나 시스템의 상황을 반영하지 못해 비효율적
    - **변동 우선순위 알고리즘**
      - 일정 시간마다 우선순위가 변함
      - 구현과 시스템이 복잡하지만 시스템 상황을 반영하여 효율적 운영이 가능



#### 7.2 우선순위 스케줄링 평가

- **장점**
  - 프로세스의 중요도를 기준으로 결정됨
    - ex) 커널 프로세스가 일반 프로세스보다 우선 실행되게 만듬



- **단점**
  - 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위반하고 아사 현상을 만듬
  - 준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하므로 오버헤드가 발생하여 시스템 효율성을 떨어뜨림



### 8. 다단계 큐 스케줄링

- **다단계 큐 스케줄링**
  - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식
  - 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위 큐에 삽입
    - 라운드 로빈 방식으로 운영되는 큐는 우선순위에 따라 다단계로 나뉘어 있어 프로세스가 큐에 삽입되는 것만으로 우선순위가 결정됨
      - 고정형 우선순위를 사용하며, 상단 큐에 있는 모든 프로세스의 작업이 끝나야 시작됨
  - 우선순위가 높은 프로세스가 들어오면 먼저 실행되므로 선점형 방식
  - 우선순위가 낮은 프로세스는 계속 대기해야 하므로 문제가 발생
    - 이를 해결하기 위해 다단계 피드백 큐 스케줄링이 제안됨



### 9. 다단계 피드백 큐 스케줄링

- **다단계 피드백 큐 스케줄링**
  - 낮은 우선순위의 프로세스에 불리함을 개선한 방식
  - 기본 형태는 다단계 큐 스케줄링과 같음(같은 우선순위를 가진 여러 개의 큐)
    - 고정 우선순위 => 변동 우선순위
      - 즉, CPU를 사용하고 난 프로세스는 원래 큐가 아닌 우선순위가 하나 낮은 큐에 끝으로 들어감
        - 낮아져도 커널 프로세스가 일반 프로세스 큐에 삽입되지는 않음	
    - 타임 슬라이스의 차등
      - 우선순위가 낮을수록 해당 큐의 타임 슬라이스가 커짐
      - 변동 우선순위를 적용했어도 낮은 우선순위가 CPU를 얻을 확률이 낮기 때문
        - 가장 우선순위가 낮은 프로세스는 무한대의 타임 슬라이스를 얻음
  - 오늘 날 운영체제가 CPU 스케줄링을 위해 사용하는 방식(변동 우선순위 알고리즘의 전형적인 예)
    - 유닉스가 10~200ms 타임 슬라이스를 갖는 이유



## 5. [심화학습] 인터럽트 처리

### 1. 인터럽트 처리

- 입출력뿐만 아니라 시스템을 보호하는 매우 중요한 작업



- **이벤트**
  - 윈도우의 다양한 버튼이 있는데 이 버튼이 눌렸는지 안눌렸는지 어떻게 확인할 것인가?
  - 매번 주기적으로 확인하는 방식은 매우 비효율적임!
  - 대신 이벤트를 발생시켜 알리는데 이것이 바로 **인터럽트**



### 2. 동기적 인터럽트와 비동기적 인터럽트

- **동기적 인터럽트(사용자 인터럽트)**
  - 프로세스가 실행 중인 명령어로 인해 발생하는 경우
  - ex)
    - 프로그램상의 문제 때문에 발생하는 인터럽트(ex - 다른 사용자의 메모리에 접근, 오버플로나 언더플로 등)
    - 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트(ex - `ctrl+C`)
    - 입출력장치 같은 주변장치의 조작에 의한 인터럽트
    - 산술 연산 중 발생하는 인터럽트(ex - 어떤 수를 0으로 나눔)



- **비동기적 인터럽트**
  - 실행중인 명령어와는 무관하게 발생하는 경우



### 3. 인터럽트 처리 과정

- 인터럽트
  - 해당 인터럽트가 발생하면 어떤 일을 할지가 정의되어 있음
    - 즉 인터럽트 번호와 그 번호에 붙어있는 함수의 쌍으로 이우러져 있음
      - 예를 들어 윈도우 화면의 최소화 버튼에서 창을 작게 만드는 함수가 정의되어 있어 누르면 창이 작아지는 것
  - 고유 번호
    - 시스템에는 많은 인터럽트가 존재하고 각각의 인터럽트에는 고유 번호, 즉 인터럽트 번호가 있음
      - 윈도우에서는 **IRQ**라고 함(시스템에서 인터럽트가 발생하면 IRQ로 인터럽트를 식별)
  - 인터럽트 벡터
    - 인터럽트의 집합으로 여러 개가 동시에 발생하면 묶어서 처리
    - 리스트의 형태로 해당 인덱스의 인터럽트가 발생하면 0에서 1로 바뀌는 형태
    - 각 인터럽트를 처리하는 함수가 연결되어 있음
      - **인터럽트 핸들러**: 해당 인터럽트가 발생하면 어떻게 처리할 것인가를 정의한 함수
        - 함수는 바꿀 수 있음



- 처리 과정	
  1. 인터럽트가 발생하면 현재 실행 중인 프로세스는 일시 정지 상태
     - 재시작하기 위해 현재 프로세스 관련 정보를 임시로 저장
  2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정
     - 여러 개가 발생했다면 인터럽트의 우선순위를 고려하여 중요 인터럽트부터 처리하도록 순서를 결정
  3. 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행
     - 인터럽트 핸들러는 미리 정의된 함수
     - 인터럽트 벡터는 인터럽트 핸들러와 일대일로 연결한 자료 구조
  4. 인터럽트 핸들러가 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료
     - 발생한 인터럽트가 입출력 완료 같은 경우면 일시 정지된 프로세스는 다시 실행
     - 다른 프로세스의 메모리 영역 침범이나 오류 같은 경우면 종료



### 4. 인터럽트와 이중 모드

- 프로세스
  - 커널 프로세스와 사용자 프로세스가 존재
  - 커널 프로세스가 실행되는 상태를 커널 모드, 사용자 프로세스가 실행되는 상태를 사용자 모드라 함
  - 만약 사용자 프로세스가 커널 기능(하드디스크 입출력 등)을 사용하려면 시스템 호출을 이용하여 커널 프로세스의 작업을 요청해야 함
    - 사용자 프로세스는 시스템 호출을 요청한 후 대기 상태로 전환되고 커널 프로세스는 요청 받은 작업을 철리함
    - 이와 같이 운영체제가 두 모드를 전환하며 일 처리를 하는 것을 **이중 모드**라고 함



- **이중 모드**
  - 운영체제가 자원을 보호하기 위해 사용하는 기법
    - 사용자 프로세스가 시스템 자원에 직접 접근하면 문제가 발생할 수 있음
    - 따라서 커널은 시스템 호출만으로 자원에 접근하게 제한함(사용자 프로세스는 커널모드에 실행 X)



- **API**(Application Programming Interface)
  - 커널이 제공하는 시스템 호출은 사용하기가 어렵고 제한적이므로 다양한 방법으로 시스템 호출을 사용하기 위해 운영체제는 API를 제공함



- 사용자가 커널 모드로 진입하는 경우
  1. 시스템 호출을 사용한 경우
     - 사용자 프로세스가 자발적으로 접근하는 경우
  2. 인터럽트를 발생시킨 경우
     - 비자발적인 경우로 잘못된 명령을 수행하여 동기적 인터럽트가 발생한 경우이므로 강제 종료됨
