# Chapter1 운영체제의 개요

[[_TOC_]]

## 1. 운영체제 소개

### 1. 일상생활 속의 운영체제

- 운영체제의 종류
  - 컴퓨터에서의 운영체제 
    - 개인용  - 윈도우, MAC
    - 대형 컴퓨터 - 유닉스, 리눅스
  - 모바일에서의 운영체제
    - iOS, 안드로이드
  - 임베디드 운영체제
    - 스마트 시계, 스마트 TV 등 CPU의 성능이 낮고 메모리 크기도 작은 시스템에 내장하게 만들어짐
    - 임베디드 운영체제가 있으면 처음 만들어질 당시의 기능 이외의 기능을 추가할 수 있음 



### 2. 운영체제의 필요성

- 초기에는 정해진 계산만을 수행했기 때문에 컴퓨터에 운영체제가 필요 없었음
  - 그러나 성능이 향상되어 여러 작업을 동시에 수행할 수 있게 되면서 사용 규칙이 필요해짐



- 운영체제의 필요성
  - 복잡한 기능을 구현하기 쉬움
  - 새로운 기능의 추가나 성능 변경이 가능하므로 성능 및 효율성을 꾀할 수 있음(**프로그램이 가능한 기계**)
  - 다양한 작업을 수행하는데 있어 효율적인 자원 관리가 가능
    - 사용자가 직접 자원에 접근하는 것을 막아 자원을 보호하고 관리함
    - 숨긴 자원은 **인터페이스**를 통해 보여주어 사용자의 접근을 막으면서 더 쉽게 사용할 수 있게함
  - 악의적인 응용 프로그램으로부터 컴퓨터를 보호



### 3. 운영체제의 정의

- **운영체제**
  - 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
  - 사용자에게 컴퓨터 자원을 사용할 수 있는 인터페이스를 제공하고 그 결과를 돌려줌



### 4. 운영체제의 역할

1. 자원관리
   - CPU, 메모리, 키보드, 마우스 등의 자원을 응용 프로그램에 나누어주어 원활한 작업을 수행할 수 있게 함
   - 만약, 자원을 요청한 프로그램이 여러 개라면 적당한 순서로 자원을 배분하고 적절한 시점에 회수하여 다른 프로그램에 나누어줌
2. 자원보호
   - 비정상적인 작업으로부터 컴퓨터의 자원을 지킴
3. 하드웨어 인터페이스 제공
   - 다양한 하드웨어(마우스, 키보드 등) 장치를 일관된 방법으로 사용할 수 있도록 지원
   - 하드웨어 인터페이스 지원은 **드라이버**를 설치해야 가능함
     - 드라이버는 하드웨어와 상호작용하기 위해 만들어진 컴퓨터 프로그램
4. 사용자 인터페이스 제공
   - 사용자가 운영체제를 편리하게 사용할 수 있도록 지원
   - 대표적으로 **GUI**(그래픽 사용자 인터페이스)나 **터치스크린** 등



### 5. 운영체제의 목표

1. 자원관리 => **효율성**
   - 적은 자원을 이용하여 결과를 빨리 보여줘야 함
   - 일반적으로 운영체제의 크기를 최소화하고 운영체제가 사용하는 코드를 최적화해야 가능
2. 자원보호 => **안정성**
   - 사용자와 응용 프로그램의 안전 문제와 하드웨어적인 보안 문제를 처리할 수 있어야 함
   - 또한, 시스템에 문제가 발생했을 때 이전으로 복구하는 결함 포용 기능을 수행해야 함
3. 하드웨어 인터페이스 제공 => **확장성**
   - 다양한 시스템 자원을 추가하거나 제거하기가 편리해야 함
   - **플러그 앤드 플레이**(하드웨어의 종유에 상관없이 꽂으면 바로 실행할 수 있는 기능) 기능 제공
   - 하드웨어 제작자의 편리성 또한 고려해야 함
4. 사용자 인터페이스 제공 => **편리성**
   - 사용자가 편리하게 작업할 수 있는 환경을 제공
   - 효율성만을 높이려면 사용자에게 무수한 제약을 가하면 됨
     - 하지만, 편리성 또한 운영체제의 목표



## 2. 운영체제의 역사

### 1. 개요

| 구분 | 시기          | 주요 기술              | 특징                                                         |
| ---- | ------------- | ---------------------- | ------------------------------------------------------------ |
| 0기  | 1940년대      | 없음                   | - 진공관(0과 1) 사용                                         |
| 1기  | 1950년대      | 카드 리더, 라인 프린터 | - 일괄 작업 시스템<br />- 운영체제 등장                      |
| 2기  | 1960년대 초반 | 키보드, 모니터         | - 대화형 시스템                                              |
| 3기  | 1960년대 후반 | C 언어                 | - 다중 프로그래밍 기술 개발<br />- 시분할 시스템             |
| 4기  | 1970년대      | PC                     | - 개인용 컴퓨터의 등장<br />- 분산 시스템                    |
| 5기  | 1990년대      | 웹                     | - 클라이언트/서버 시스템                                     |
| 6기  | 2000년대      | 스마트폰               | - P2P 시스템(메신저, 파일 공유)<br />- 그리드 컴퓨팅<br />- 클라우드 컴퓨팅<br />- 사물 인터넷 |



### 2. 초창기 컴퓨터(1940년대)

- 애니악(최초의 컴퓨터)
  - 미사일의 탄도 계산을 위해 개발
  - 백열전구 같은 모양의 진공관이라는 소자를 사용하여 진공관이 켜지면 1, 꺼지면 0이라고 판단했는데, 이는 컴퓨터가 2진법을 사용하는 계기가 됨
  - 키보드, 마우스, 모니터와 같은 주변 장치 없이 18,000개의 전선으로 연결한 것으로 프로그램을 대신함
    - **하드와이어링**: 전선을 연결하여 논리회로를 구성하는 것



### 3. 일괄 작업 시스템(1950년대)

- **IC 칩**
  - 진공관과 전선으로 만든 논리회로를 매우 작은 크기로 구현함
  - 이 칩을 이용한 컴퓨터에는 미약하나 CPU와 메인메모리가 있었음
  - 천공카드 리더를 입력장치로 사용
    - OMR의 원조 격으로 구멍을 뚫어 문자나 숫자를 표현
  - 라인 프린터를 출력장치로 사용
    - 문자만 출력하는 프린터로 한 번에 한 줄씩 출력



- **일괄 작업 시스템(또는 일괄 처리 시스템)**
  - 당시 컴퓨터는 천공카드 리더로 하나의 작업을 읽어들여 실행하고 결과를 출력한 후 다음 작업을 수행함
  - 즉, 다중 작업 수행이 불가능한 **일괄 작업 시스템**



### 4. 대화형 시스템(1960년대 초반)

- 키보드와 모니터의 등장
  - 이는 비효율적이던 일괄 작업 시스템을 획기적으로 발전시킴
    - 작업 중간에 사용자가 입력을 하거나 사용자에게 중간 결과값을 보여줄 수 있게 됨
    - 프로그램이 진행되는 도중에 사용자로부터 입력을 받아 작업의 흐름을 바꾸는 것도 가능해짐
  - 사용자와 대화를 통해 작업이 이루어져 이를 **대화형 시스템**이라고 일컫음
  - 다만, 일괄 작업 시스템은 입출력이 거의 없어 작업 시간을 예측할 수 있었지만, 대화형 시스템은 예측이 어려움



- CPU 작업
  - **집중 작업**
    - 일괄 작업 시스템에서는 프로그램이 실행되는 동안에 입출력이 불가능하기 때문에 대부분의 작업이 CPU만 사용하는 계산 작업
  - **입출력 집중 작업**
    - 대화형 시스템에서는 프로그램이 실행되는 동안 입출력이 가능하기 때문에 입출력 집중 작업이 생김



### 5. 시분할 시스템(1960년대 후반)

#### 5.1 시분할 시스템 개념

- **다중프로그래밍**
  - CPU 사용 시간을 아주 잘게 쪼개어 여러 작업에 나누어 줌
  - 이때 잘게 나뉜 시간 한 조각을 **타임 슬라이스** 또는 **타임 퀀텀**이라 함



- **단점**
  - 여러 작업을 동시에 처리하기 위한 추가 작업이 필요함
  - 시스템 내의 많은 작업이 공존할 경우, 중요한 작업이 일정 시간 안에 끝나는 것을 보장하지 못함
    - 따라서 원자력, 미사일 제어 시스템은 일정 시간 안에 작업 처리를 보장하는 실시간 시스템을 사용



- 실시간 시스템
  - **경성 실시간 시스템**
    - 지정한 응답 시간을 정확히 지키는 시스템(ex - 원자력, 미사일 제어 시스템 등)
  - **연성 실시간 시스템**
    - 지정한 응답 시간을 최대한 지키지만 융통성이 어느 정도 허용된 시스템(ex - 동영상 재생기)



#### 5.2 다중 사용자 시스템

- **멀티프로그래밍 수준**
  - 시분할 시스템에서 동시에 실행되는 작업의 개수



- 다중 작업
  - 시분할에서 다중 작업을 수행할 수 있다는 것은 여러 프로그램 또는 여러 사람이 작업할 수 있다는 의미



### 6. 분산 시스템(1970년대 후반)

- 1970년대 후반
  - 스티븐 잡스가 1977년 최초의 개인용 컴퓨터 '애플 II'를 발표
  - 인터넷이 등장



- 분산 시스템
  - 기존에는 복잡한 계산이나 많은 양의 데이터를 처리하기 위해 **메인프레임**이라는 고가의 대형 컴퓨터를 사용
  - 개인용 컴퓨터와 인터넷의 등장으로 값이 싸고 크기가 작은 컴퓨터들을 하나로 묶은 **분산 시스템**을 구현
    - 네트워크상에 분산되어 있는 여러 컴퓨터로 작업을 처리하고 그 결과를 상호 교환하는 시스템



### 7. 클라이언트/서버 시스템(1990년대~현재)

- 클라이언트/서버 시스템
  - 분산 시스템의 단점을 해결한 기술
    - 모든 컴퓨터가 동일한 지위이므로 컴퓨터가 고장나거나 추가되면 작업을 분배하고 결과를 모으기 어려움
  - 요청하는 클라이언트와 거기에 응답하여 요청받는 작업을 처리하는 서버의 이중 구조로 나뉨



- **데몬**
  - 멈추지 않고 계속 작동하는 프로그램을 일컫음
  - 데몬을 가진 컴퓨터를 서버라고 부름
    - 웹 데몬이 설치된 컴퓨터는 웹 서버
    - FTP 데몬이 설치된 컴퓨터는 FTP 서버
    - 등등



### 8. P2P 시스템(2000년대 초반~현재)

#### 8.1 P2P 시스템의 개념

- **P2P 시스템**
  - 서버의 부하를 줄일 수 있는 시스템
  - peer는 말단 노드(사용자 컴퓨터), P2P는 서버를 거치지 않고 사용자와 사용자를 직접 연결
  - 서버는 파일 검색만 맡고 사용자간 파일 전송이 이루어지므로 서버 부하가 적음



#### 8.2 P2P 시스템의 예: 메신저

- 메신저 시스템
  - 수만 명이 동시에 채팅을 하고 파일을 주고받는 메신저 시스템은 클라이언트/서버 구조로 만들 수 없고 P2P 기술을 이용해야 함
  - 메신저에 로그인하면 먼저 서버에 접속하여 사용자 인증과 출석 등의 정보를 받음
    - 출석은 친구나 관련자가 현재 어디에 있는지, 어떤 상태인지 확인하는 과정
  - 해당 절차를 완료하면 서버를 거치지 않고 사용자 간에 채팅을 하거나 데이터를 전달할 수 있음



#### 8.3 P2P 시스템의 예: 파일 공유

- 대용량 파일 공유 P2P 시스템
  - 같은 파일을 가진 여러 사람으로부터 데이터를 나누어 받음
    - 기존 P2P 시스템에서는 보내는 쪽에서 프로그램을 꺼버리면 전송이 중단되므로 문제점이 있었음
  - 한 명에게 받을 때보다 더 빠르고, 한 두명이 프로그램을 중단해도 다른 사람들에게 받을 수 있음



- 서버에 따른 P2P 시스템
  - 서버가 있는 P2P 시스템
    - 사용자 인증과 출석 정보, 과거 데이터 보관 등을 위해 서버가 있는 경우
  - 서버가 없는 P2P 시스템
    - 비트코인의 블록체인 등
      - 비트코인은 가상화폐로 이를 사고 팔 때 장부를 기록할지 정할 수 없음
      - 따라서 블록체인을 이용하여 모든 시스템이 거래 장부를 가지고, 전체 시스템의 50% 이상이 동의했을 때만, 거래 장부의 변경이 가능하게 만듬



### 9. 기타 컴퓨터 환경(2000년대 초반~현재)

#### 9.1 그리드 컴퓨팅

- **그리드 컴퓨팅**
  - 필요한 컴퓨팅 자원을 구매하여 사용하는 컴퓨팅 환경(분산 시스템의 한 분야)
  - 서로 다른 기종의 컴퓨터들을 묶어 대용량 컴퓨터 풀을 구성하고 이를 원격지와 연결하여 대용량 연산을 수행



- **그리드 딜리버리**
  - 대용량 파일 공유 P2P 시스템에서 사용자가 내려받고자 하는 파일을 다른 사람의 컴퓨터에서 몰래 빼오는 기술



- **SaaS**
  - 사용자가 필요할 때 소프트웨어 기능을 이용하고 그만큼만 비용을 지불하는 개념
    - 그리드 컴퓨팅은 하드웨어적인 컴퓨팅 환경의 통합
  - 프로그램을 설치하거나 업데이트할 필요 없이 인터넷만 접속하면 이용 가능하다는 장점이 있음



#### 9.2 클라우드 컴퓨팅

- **클라우드 컴퓨팅**
  - 언제 어디서나 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경
    - 그리드 컴퓨팅과 Saas를 합쳐놓은 형태
  - PC, 스마트 기기 등을 통해 인터넷에 접속하고, 다양한 작업을 수행하며, 기기 간의 데이터 이동이 자유로운 컴퓨팅 환경



#### 9.3 사물 인터넷

- **사물 인터넷**
  - 사물에 센서와 통신 기능을 내장하여 인터넷에 연결하는 기술
  - 인터넷으로 연결된 사물들이 데이터를 주고받아 스스로 분석하고 학습한 정보를 사용자에게 제공하거나 새로운 서비스를 창출



## 3. 운영체제의 구조

### 1. 커널과 인터페이스

- **운영체제의 큰  구조**

  1. **커널**
     - 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심 기능을 모아놓은 것
     - 운영체제의 성능을 좌우함
  2. **인터페이스**
     - 커널에 사용자의 명령을 전달하고 실행 결과를 사용자에게 알려주는 역할

  - 운영체제는 커널과 인터페이스를 분리하여, 같은 커널을 사용하더라도 다른 인터페이스를 가진 형태로 제작 가능
    - 즉, 인터페이스에 따라 여러 운영체제로 보이게 됨



### 2. 시스템 호출과 디바이스 드라이버

- 시스템 호출과 드라이버는 커널 내부에 존재함

#### 2.1 시스템 호출

- **시스템 호출**
  - 커널이 자신을 보호하기 위해 만든 인터페이스
    - 커널은 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근을 차단함
    - 따라서 자원을 이용하려면 인터페이스를 이용해야 함
      - 직접 접근이 아닌 시스템 호출을 통한 접근
  - 정리
    - 시스템 호출은 커널이 제공하는 시스템 자원의 사용과 연관된 함수
    - 응용 프로그램이 하드웨어 자원에 접근하거나 운영체제가 제공하는 서비스를 이용하려 할 때는 시스템 호출을 사용해야 함
    - 운영체제는 커널이 제공하는 서비스를 시스템 호출로 제한하고 다른 방법으로 커널에 들어오지 못하게 막음으로써 컴퓨터 자원을 보호
    - 시스템 호출은 커널이 제공하는 서비스를 이용하기 위한 인터페이스이며, 사용자가 자발적으로 커널 영역에 진입할 수 있는 유일한 수단



- **API**와 **SDK**
  - **API**
    - 응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스
    - 예를 들어 포토샵에서 필터를 개발하려는 사람들을 위해  제공하는 프로그래밍 인터페이스가 API
    - API는 시스템 호출보다 광범위한 개념이며, 운영체제의 API를 시스템 호출이라고 정의할 수 있음
  - **SDK**
    - 프로그램 개발자를 위해 API 및 API 사용 매뉴얼뿐만 아니라 프로그램 개발에 필요한 코드 편집기와 에뮬레이터 같은 각종 개발용 응용 프로그램까지 하나로 묶어서 배포하는 **개발 툴**



#### 2.2 드라이버

- **드라이버**
  - 커널과 하드웨어의 인터페이스
  - 커널은 기본적인 입출력만 제작하고, 하드웨어의 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행되게 함
    - 이때 하드웨어 제작자가 만든 소프트웨어를 디바이스 드라이버라고 일컫음
  - 커널이 제공하는 시스템 호출 없이는 자원에 접근할 수 없는 것과 달리, 하드웨어는 커널이 제공하는 드라이버도 있고, 하드웨어 제작자가 제공하는 드라이버도 있음



### 3. 커널의 구성

- 커널의 역할

  | 핵심 기능             | 설명                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | 프로세스 관리         | 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공     |
  | 메모리 관리           | 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공 |
  | 파일 시스템 관리      | 데이터를 저장하고 접근할 수 있는 인터페이스를 제공           |
  | 입출력 관리           | 필요한 입력과 출력 서비스를 제공                             |
  | 프로세스 간 통신 관리 | 공동 작업을 위한 각 프로세스 간 통신 환경을 지원             |

  - 이러한 기능의 구현 방식에 따라 단일형 구조 커널, 계층형 구조 커널, 마이크로 구조 커널로 구분됨



#### 3.1 단일형 구조 커널

- **단일형 구조 커널**
  - 초창기의 운영체제 구조로, 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성됨
    - 함수가 거의 없이 `main()`에 모든 기능을 구현한 형태
  - **장점**
    - 모듈이 거의 없으므로 모듈 간 통신 비용이 줄어 효율적인 운영이 가능(함수 호출의 오버헤드가 없음)
  - **단점**
    - 모듈이 하나로 묶여 있어 오류나 버그 처리가 어려움
    - 운영체제의 여러 기능이 서로 연결되어 있어 상호 의존성이 높기 때문에 기능상 작은 결함이 시스템으로 확산될 수 있음
    - 수정이 어럅기 때문에 다양한 환경의 시스템에 적용하기 어려움
      - 여러 종류의 컴퓨터에 이식하려면 수정이 필요
    - 현대 운영체제는 매우 크고 복잡하기 때문에 완전 단일형 구조의 운영체제는 구현이 어려움



#### 3.2 계층형 구조 커널

- **계층형 구조 커널**
  - 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층 간의 통신을 통해 운영체제를 구현
  - **장점**
    - 모듈화했기 때문에 버그나 오류를 쉽게 처리할 수 있고, 디버깅도 쉬움
    - 대부분의 운영체제는 이 구조
  - **단점**
    - 다양한 하드웨어와 사용자의 요구를 수용하기 위해 계속 셰층과 기능을 추가하여 커널의 크기가 커지고 하드웨어 용량이 늘어남
    - 커널 소스가 방대해져 오류를 잡기도 어려워짐



#### 3.3 마이크로 커널 구조

- **마이크로 커널 구조**
  - 프로세스 관리, 메모리 관리, 프로세스 간 통산 관리 등 가장 기본적인 기능만 제공
  - 커널은 메모리 관리와 프로세스 간의 동기화 서비스를 제공하며, 메모리 관리자와 동기화 모듈은 프로세스 간 통신 모듈로 연결됨
    - 즉, 각 모듈은 세분화되어 존재하고 모듈 간의 정보 교환은 프로세스 간 통신을 이용하여 이뤄짐
  - 각 모듈이 독립적이므로 하나의 모듈이 실패해도 전체 운영체제가 멈추지 않음
  - 또한 많은 컴퓨터에 이식하기 쉽고 커널이 가벼워 CPU 용량이 작아도 적용이 가능



#### 4. 가상머신

- **호환성 문제**
  - C 언어는 어셈블리어 같은 저급 언어의 기능을 가지고 있어 시스템 프로그래밍 언어에 적합하나 다른 커널을 가진 운영체제와의 호환성이 떨어짐
    - 즉, 응용 프로그램을 만들 때 각 운영체제마다의 버전을 따로 만들어야 함을 의미
  - 이러한 호환성 문제를 해결한 언어가 **자바**
    - 자바로 프로그래밍을 하면 대부분의 운영체제에서 작동하므로 코드를 수정할 필요가 없어짐
      - 이 원리는 운영체제 위에 **가상머신**을 만들고 그 위에서 응용 프로그램이 작동하게 만듬
      - **JVM**(자바 가상머신)으로 불림

