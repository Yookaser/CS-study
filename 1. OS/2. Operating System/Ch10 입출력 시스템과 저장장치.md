# Chapter10 입출력 시스템과 저장장치

[[_TOC_]]

## 1. 입출력 시스템

### 1. 입출력장치와 채널

- 컴퓨터의 구조
  - CPU, 메모리, 주변장치인 입출력장치와 저장장치로 구성되며, 각 장치는 메인보드에 있는 버스로 연결되는데, 이때 주변장치는 전송 속도에 따라 구분할 수 있음
    - **저속 주변장치**
      - 메모리와 주변장치 사이에 오고 가는 데이터의 양이 적어 데이터 전송률이 낮은 장치
        - 예를 들어 키보드는 1초에 1KB를 넘지 않으므로 저속 주변장치
    - **고속 주변장치**
      - 메모리와 주변장치 사이에 대용량의 데이터가 오고 가므로 데이터 전송률이 높은 장치
        - 예를 들어 그래픽 카드와 하드디스크는 대용량 데이터를 옮겨야 하므로 고속 주변장치
  - **채널**
    - 데이터가 지나다니는 통로(여러 개의 버스를 묶은 것 => 버스 한 개로는 병목 현상이 발생함)
    - **채널 공유**: 여러 데이터가 채널을 공유함(데이터마다 속도가 다르기 때문에 느림)
    - **채널 분리**: 속도가 비슷한 장치끼리 묶음(전체 데이터 전송 속도를 향상시킬 수 있음)



### 2. 입출력 버스의 구조

#### 2.1 초기의 구조

- 초기
  - 주변장치가 많지 않고, CPU와 메모리 속도가 빠르지 않음
  - 모든 장치가 하나로 연결되고, CPU가 작업을 진행하다 입출력 명령을 만나면 직업 입출력 장치에서 데이터를 가져옴(**폴링**)
    - 폴링이 끝날때까지 다른 작업을 할 수 없었음



#### 2.2 입출력 제어기를 사용한 구조

- 중기?
  - 주변 장치가 많아지고, CPU와 메모리의 성능도 급격히 향상됨
  - CPU가 폴링으로 모든 주변장치를 관리하기 어렵기 때문에 **입출력 제어기**에 모든 입출력을 맡기게 됨
    - 느린 입출력장치로 인해 CPU와 작업이 느려지는 것을 막음
    - 입출력 제어기는 2개의 채널을 가짐
      - **메인버스**: 고속으로 작동하는 CPU와 메모리가 사용
      - **입출력 버스**: 주변장치가 사용



#### 2.3 입출력 버스의 분리

- 후기?
  - 입출력 제어기로 작업 효율은 높였으나, 저속 주변장치로 인해 데이터 전송이 느려지는 문제가 있음
    - 이를 해결하기 위해 입출력 버스를 **고속 입출력 버스**와 **저속 입출력 버스**로 분리하여 운영함
      - 고속 입출력 버스는 고속 주변장치를 연결하고 저속 입출력 버스는 저속 주변장치를 연결
      - 두 버스 사이의 데이터 전송은 **채널 선택기**가 관리
  - 그래픽카드
    - 3D 게임 등으로 그래픽카드가 할 일이 많아짐에 따라 GPU가 부착됨
    - GPU가 다루는 데이터는 고속 입출력 버스로 감당이 안되므로 메인버스에 바로 연결하여 사용
      - CPU, 메모리도 메인버스에 직접 연결



### 3. 직접 메모리 접근

- **직접 메모리 접근**(**DMA**)
  - CPU의 도움 없이도 메모리에 접근할 수 있도록 입출력 제어기에 부여된 권한
    - 입출력 메모리에 직접 메모리 접근을 위한 **DMA 제어기**가 마련되어 있음
  - 입출력 제어기의 진행 과정
    - 여러 채널에 연결된 주변 장치로부터 전송된 데이터를 적절히 배분하여 하나의 데이터 흐름을 만듬
    - 채널 선택기는 여러 채널에서 전송된 데이터  중 어떤 것을 메모리로 보낼지 결정
    - 주변장치에서 전송된 데이터는 DMA 제어기를 거쳐 메모리에 올라감
    - 반대로 메모리에서 주변장치로 데이터를 전송할 때는 DMA 제어기가 메모리에서 데이터를 가져오면 채널 선택기에서 적당한 채널로 전송
  - 메인메모리는 CPU와 DMA의 공동 작업 공간이 되는 것
    - 이로 인한 문제를 예방하기 위해 두 작업공간을 분리하고 이를 **메모리 맵 입출력**이라 함
    - 메모리 맵 입출력
      - 메인메모리 주소 공간 중 일부를 DMA 제어기에 할당하여 작업 공간이 겹치는 것을 막음



### 4. 인터럽트

#### 4.1 입출력과 인터럽트

- 인터럽트

  - 입출력 제어기와 DMA 제어기의 협업으로 작업이 완료되면 인터럽트가 발생함
  - 컴퓨터에는 다양한 인터럽트가 있으므로 CPU는 어떤 인터럽트인지 확인해야 함
    - 이를 위해 IRQ라는 고유의 인터럽트 번호가 부여되어 있음

  

- 인터럽트 종류

  - **외부 인터럽트**(**하드웨어 인터럽트**)
    - 입출력장치로부터 오는 인터럽트뿐만 아니라 전원 이상이나 기계적 오류 때문에 발생하는 인터럽트
  - **내부 인터럽트**(**예외 상황 인터럽트**)
    - 프로세스 오류와 관련된 인터럽트(0으로 나누기, 자신의 주소 공간을 벗어나서 작업 등)
  - **시그널**
    - 사용자의 의지로 발생시키는 자발적 인터럽트

  | 종류   | 특징                    | 비고1                        | 인터럽트 번호 | 비고2                   |
  | ------ | ----------------------- | ---------------------------- | ------------- | ----------------------- |
  | 외부   | 입출력 및 하드웨워 관련 | 주변장치 변화, 하드웨어 이상 | 0~31          | 20~31번은 정의 안됨     |
  | 내부   | 프로세스 오류           | 예외 상황 인터럽트           | 32~47         | 주변장치에 따라 유동적  |
  | 시그널 | 사용자 요청             | 자발적 인터럽트              | 128           | 시그널 번호를 따로 기재 |

  - 인터럽트 번호와 IRQ
    - IRQ는 하드웨어 각 장치를 구분하기 위해 붙인 번호이므로 인터럽트 번호와 다름
    - 예를 들어 IRQ 0번은 인터럽트 번호 32번이고 IRQ 15번은 인터럽트 번호 47번임



#### 4.2 인터럽트 벡터와 인터럽트 핸들러

- **인터럽트 벡터**
  - 여러 인터럽트 중 어떤 인터럽트가 발생했는지 파악하기 위한 자료 구조
    - 각 인덱스 번호는 해당 인터럽트 번호를, 값은 발생 여부를 의미(1 => 발생)
  - 인터럽트마다 처리 방법도 다양하므로 인터럽트 핸들러가 존재하고 벡터에는 해당 인터럽트 핸들러를 호출하기 위한 메모리 주소가 포인터 형태로 등록되어 있음



### 5. 버퍼링

#### 5.1 버퍼의 역할

- **버퍼**
  - 속도가 다른 두 장치의 속도 차이를 완화하는 역할로 데이터를 버퍼에 모아 한꺼번에 이동함
    - 하드디스크 등 대부분의 입출력장치가 사용
    - 커널에서도 입출력장치로 보내야 할 데이터를 버퍼에 담아놓으면, 입출력 제어기가 커널 버퍼에서 입출력장치로 데이터를 보냄
      - 입출력 작업이 완료되기 전에 다른 작업을 할 수 있어 시스템 성능이 좋아짐
  - **이중 버퍼**
    - 하나의 버퍼는 데이터를 담고, 다른 하나는 데이터를 가져가는 용도로 사용 가능하여 효율적
    - 단일 버퍼로는 동시에 수행하기 어려움



#### 5.2 버퍼 운용 시 주의점

- 버퍼의 운용
  - 시스템 효율성을 위해 운영체제는 버퍼가 꽉 찼을 때 입출력장치로 데이터를 전송하도록 설계
    - 때문에 버퍼가 다 차지 않았는데, 저장장치를 제거하면 버퍼 안 데이터가 저장되지 않게되는 문제가 존재
  - **플러시**
    - 윈도우에서 **하드웨어 안전 제거**를 사용하면 버퍼가 다 차지 않아도 강제로 버퍼의 내용을 저장장치로 옮김



## 2. 디스크 장치

### 1. 디스크 장치의 종류

#### 1.1 하드디스크

- 하드디스크
  - 원반을 사용한 저장장치(맨 앞이나 맨 뒤에 있는 데이터에 접근하는 속도가 거의 비슷함)
  - 반영구적으로 사용 가능하며 메모리를 보조하는 장치로 제2저장장치로 불림



- 하드디스크 구조
  - **플래터**
    - 자성체가 발려 있어 자기를 이용하여 0과 1의 데이터를 저장(0 => N극, 1 => S극)
    - 통상 2장 이상으로 구성되며 항상 일정한 속도로 회전함
      - 7,500rpm이라면 1분에 7,500바퀴를 회전한다는 의미
    - 한 플래터는 위아래 표현을 다 사용하므로 2개의 표면에 데이터가 저장
      - 일부 모델은 맨 위, 맨 아래 디스크의 바깥면을 사용하지 않는 경우도 있음
  - **섹터**와 **블록**
    - **섹터**: 하드디스크의 가장 작은 저장 단위
    - **블록**: 하드디스크와 컴퓨터  사이에 데이터를 전송하는 논리적인 저장 단위 중 가장 작은 단위
      - 여러 개의 섹터로 구성되며, 윈도우 운영체제에서는 블록 대신 **클러스터**라 함
    - 즉, 하드디스크에서 가장 작은 저장 단위는 섹터이나 운영체제 입장에서는 하드디스크에 데이터를 보내거나 받을 때 블록이 가장 작은 단위
  - **트랙**과 **실린더**
    - **트랙**: 플래터에서 회전축을 중심으로 데이터가 기록되는 동심원, 즉 동일한 동심원상에 있는 섹터의 집합을 의미
    - **실린더**: 여러 개의 플래터에 있는 같은 트랙의 집합
      - 헤드는 디스크 암에 고정되어 있기 때문에 모든 헤드는 항상 같이 움직임
      - 즉 헤드는 여러 플래터의 같은 위치에 있는 트랙을 동시에 읽을 수 있음
  - **헤드**와 **플래터**
    - **헤드**
      - 하드디스크에서 데이터를 읽거나 쓸 때 사용
        - 따라서 헤드의 수는 데이터가 저장되는 플래터의 수와 동일함
      - 매우 가벼운 물질로 플래터가 회전할 때 발생하는 바람으로 약간 떠 있는 형태로 작동
        - 만약 헤드가 붙어버리면 고속으로 회전할 때 플래터 표면에 상처가 생김(**배드 섹터**)
        - 컴퓨터 정상 종료시에는 플래터의 맨 바깥쪽(데이터가 저장되지 않는)으로 이동함(**파킹**)



#### 1.2 CD

- CD
  - 하드디스크와 마찬가지로 트랙과 섹터로 구성되며, 수평으로 움직이는 헤드가 트랙 사이를 움직이며 데이터를 읽음
    - CD에는 미세한 홈이 파여 있어 헤드에서 발사된 레이저가 홈에 들어가면 반사가 되지 않음
    - 반사가 안되면 0, 반사가 되어 돌아오면 1로 인식



### 1.3 하드디스크와 CD의 비교

- **rpm**과 **배속**
  - 하드디스크는 성능을 나타내는 단위로 rpm을 사용하고, CD는 배속을 사용
  - 하드디스크는 디스크가 작동하는 동안 일정한 속도로 돌아가지만, CD의 경우 헤드 위치에 따라 회전 속도가 변하기 때문에 표현 용어가 다름



- 회전 방식
  - 하드디스크
    - **각속도 일정 방식의 회전**
      - 플래터는 항상 일정한 속도로 회전하여 바깥쪽 트랙의 속도가 안쪽 트랙의 속도보다 훨씬 빠름
      - 따라서 가장 바깥쪽에 있는 섹터가 가장 안쪽에 있는 섹터보다 더 큼
  - CD
    - **선속도 일정 방식의 회전**
      - 어느 트랙에서나 단위 시간당 디스크의 이동 거리가 같음
      - 이를 구현하려면 헤드가 안쪽 트랙에 있을 때는 디스크의 회전 속도를 빠르게 하고, 바깥쪽 트랙에 있을 때는 디스크의 회전 속도를 느리게 해야 함



- 섹터의 구성
  - 하드디스크
    - **각속도 일정 방식의 섹터**
      - 트랙마다 속도가 다르므로 섹터의 크기도 다름(바깥쪽이 더 큼)
      - **장점**
        - 일정한 속도로 회전하므로 구동 장치가 단순하고 조용함
      - **단점**
        - 바깥쪽으로 갈수록 낭비되는 공간이 생김
  - CD
    - **선속도 일정 방식의 섹터**
      - 모든 트랙의 움직이는 속도가 같고 섹터의 크기도 같음(바깥쪽에 섹터가 더 많음)
      - **장점**
        - 한정된 공간에 많은 데이터를 담을 수 있음
        - 낭비되는 공간이 없음
      - **단점**
        - 모터 제어가 복잡하고 소음이 발생



- 데이터가 채워지는 방법
  - 하드디스크 => 바깥쪽에서 안쪽으로 채워짐
  - CD => 안쪽부터 바깥쪽으로 채워짐(보통 사용자가 바깥쪽을 잡으므로 데이터 보호를 위해)



### 2. 디스크 장치의 데이터 전송 시간

- 데이터 전송 과정

  1. 하드디스크의 특정 섹터에 저장된 데이터를 읽거나 쓰려면 그 섹터가 있는 트랙까지 헤드가 이동해야 함
     - **탐색 시간**: 헤드가 현재 위치에서 트랙까지 이동하는 데 걸리는 시간
  2. 특정 트랙으로 이동한 헤드는 플래터가 회전하여 원하는 섹터를 만날 때까지 기다림
     - **회전 지연 시간**: 원하는 섹터를 만날 때까지 회전하는 데 걸리는 시간
  3. 헤드는 원하는 섹터에 있는 데이터를 읽어 전송
     - **전송 시간**

  - **데이터 전송 시간** = 탐색시간 + 회전 지연 시간 + 전송 시간
    - 일반적으로 가장 오래 걸리는 것은 탐색시간
      - 탐색 시간을 최소화하기 위해서는 조각 모음과 디스크 스케줄링 기법을 사용하는 것
      - 보통 플래터는 7,500rpm 이상으로 동작하므로 회전 및 전송 시간은 짧음
    - 하드디스크를 오래 사용하면 점점 느려짐
      - 차곡차곡 쌓여 있던 데이터를 쓰고 지우는 과정을 반복함에 따라 조각이 발생하기 때문
      - 조각이 발생하면 큰 덩어리의 데이터를 읽을 때 헤드가 여러 곳을 돌아다녀야 하므로 느려짐



### 3. 디스크 장치 관리

#### 3.1 파티션

- **파티션**
  - 디스크를 논리적으로 분할하는 작업으로 보통 파티션 하나에 하나의 파일 시스템이 탑재\
    - 윈도우에서는 각 파티션에 이름을 부여(C, D, E, F ... 순서)
  - **마운트**
    - 유닉스 운영체제에서 여러 개의 파티션을 하나로 통합하는 기능
    - 사용자 입장에서는 여러 개의 하드디스크를 하나로 통합되면 편함



#### 3.2 포매팅

- **포매팅**
  - 디스크에 파일 시스템을 탑재하고 디스크 표면을 초기화하여 사용할 수 있는 형태로 만드는 작업
    - 빈 저장장치(파티션)의 상단부에 파일 테이블을 탑재하고 모든 섹터를 0으로 만들어 운영체제가 사용할 수 있도록 준비하는 작업
  - **파일 테이블**: 가상 주소가 메모리의 어디에 있는지 알려주는 역할
    - 윈도우에는 FAI(File Allocation), NTFS(New Technology File system) | 유닉스에는 I-node
  - 포매팅 방식
    - **빠른 포매팅**: 데이터는 그대로 둔 채 파일 테이블을 초기화하는 방식
    - **느린 포매팅**: 지금까지 설명한 방식(배드 섹터를 찾는 일도 같이 수행함)
    - 하드디스크를 처음 사용할 때는 느린 포매팅을 하고, 하드디스크를 사용하다가 다시 포매팅 할 때는 빠른 포매팅을 함
      - 일반적으로 하드디스크 제조사에서는 느린 포매팅 후 파일 테이블까지 설치한 제품을 판매함



#### 3.3 조각 모음

- **조각 모음**
  - 파일을 저장했다가 지우면 중간중간 빈 섹터가 생기는데 이를 **조각화** 또는 **단편화**라고 함
    - 이런 조각이 많이 생기면 하드디스크가 여러 곳을 돌아다녀야 하므로 성능이 저하됨
  - 단, 반도체를 이용한 저장장치는 조각 모음을 하지 않아도 됨(헤드 대신 반도체를 사용하므로)



### 4. 네트워크 저장장치

- 컴퓨터, 노트북, 스마트폰 등 여러 저장장치가 흩어져 있으므로 중복되고 관리가 어려움
  - 네트워크의 발달로 이런 중복되고 관리가 어려운 파일을 한 데 모아 관리할 수 있게됨



#### 4.1 DAS

- **DAS**(Direct Attached Storage)
  - 서버와 같은 컴퓨터에 직접 연결된 저장장치
    - 대표적으로 윈도우 파일 공유
  - 컴퓨터의 메인보드에 있는 입출력 버스와 연결됨
    - IDE -> E-IDE를 거쳐 SATA 방식(연결의 간편성, 최대 전송 속도와 연관)
  - 외부 저장장치와 컴퓨터 내부 버스를 연결하는 데는 범용 연결 단자인 **Firewire**(**IEEE1394**)를 사용
  - **단점**
    - 다른 운영체제가 쓰는 파일 시스템을 사용할 수 없음
    - 데이터의 관리나 백업을 사용자가 직접 해야 하는 번거로움이 존재



#### 4.2 NAS

- **NAS**(Network Attached Storage)
  - 기존의 저장장치에 LAN이나 WAN에 붙여서 사용하는 방식
  - NAS 전용 운영체제를 가진 독립적인 장치로 새로운 하드디스크를 추가하거나 뺄 수 있음
  - DAS의 단점을 보완하기 위해 저장장치를 네트워크상에 두고 여러 클라이언트가 네트워크를 통해 접근하게 함으로써 공유 데이터 관리 및 중복 회피
  - 프린터와 같은 주변장치로 NAS의 형태로 구현할 수 있음



#### 4.3 SAN

- **SAN**(Storage Area Network)
  - 데이터 서버, 백업 서버, RAID 등의 장치를 네트워크로 묶고 데이터 접근을 위한 서버를 두는 형태
    - 저장장치에 필요한 장치를 네트워크로 묶어 하나의 시스템을 구성하므로 다양한 서비스를 제공
    - 데이터 공유, 백업, 보안 등 서버를 통해 자동으로 이뤄지므로 사용자가 신경 쓸 필요 없음
  - **단점**
    - 여러 장치를 같이 구현하므로 구축 비용이 많이 듬
  - **종류**
    - **FC-SAN**: 대용량 데이터를 전송하기 위해 **광 채널**(fibber channel)을 이용하여 구성
    - **IP-SAN**: TCP/IP 프로토콜을 이용하여 원격지의 컴퓨터를 네트워크로 묶어 구성



## 3. 디스크 스케줄링

- **디스크 스케줄링**
  - 트랙의 이동을 최소화하여 탐색 시간을 줄이기 위함
  - 성능의 비교는 트랙의 총 이동거리



- 예시

  | 순번      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
  | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 트랙 번호 | 15   | 8    | 17   | 11   | 3    | 23   | 19   | 14   | 20   |

  

### 1. FCFS 디스크 스케줄링

- **FCFS**
  - 가장 단순한 방식으로, 요청이 들어온 트랙 순서대로 서비스



- 총거리 계산

  | 이동 | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 총계 |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 거리 | 7    | 9    | 6    | 8    | 20   | 4    | 5    | 6    | 65   |

  

### 2. SSTF 디스크 스케줄링

- **SSTF**
  - 현재 헤드가 있는 위치에서 가장 가까운 트랙을 서비스
  - 효율성은 좋으나 아사 현상을 일으킬 수 있음
    - 따라서 잘 사용하지 않음



- 총거리 계산

  | 이동      | 8    | 3    | 7    | 9    | 6    | 4    | 2    | 5    | 총계 |
  | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 현재 위치 | 15   | 14   | 17   | 19   | 20   | 23   | 11   | 8    | -    |
  | 거리      | 1    | 3    | 2    | 1    | 3    | 12   | 3    | 5    | 30   |

  

### 3. 블록 SSTF 디스크 스케줄링

- **블록 SSTF**
  - 일정한 블록 형태로 묶고, 가장 멀리 떨어져 있는 트랙을 블록에 끝으로 이동시킨 후 서비스
    - 기존 SSTF는 가장 먼 트랙을 맨 뒤로 보냈음
    - 즉 에이징을 이용하여 공평성을 보장했으나 성능은 FCFS처럼 좋지 않음



- 총거리 계산(블록 크기를 3으로 함 => 1 2 3 | 4 5 6 | 7 8 9)

  | 이동      | 2    | 3    | 4    | 5    | 6    | 8    | 7    | 9    | 총계 |
  | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 현재 위치 | 15   | 17   | 8    | 11   | 3    | 23   | 20   | 19   |      |
  | 거리      | 2    | 9    | 3    | 8    | 20   | 3    | 1    | 5    | 51   |

  

### 4. SCAN 디스크 스케줄링

- **SCAN**
  - SSTF의 공평성 위배를 완화하기 위해 만들어진 기법으로 헤드가 한 방향으로만 움직이며 서비스
    - 헤드가 움직이면 맨 마지막 트랙에 도착할 때까지 뒤돌아가지 않고 전진함(**엘리베이터 기법**)
  - 공평성을 덜 위배하면서도 성능이 좋기 때문에 많이 사용됨
  - 다만 동일한 트랙이나 실린더 요청이 연속적으로 발생하면 헤드가 더 나아가지 못하고 제자리에 머물게 되어 바깥쪽 트랙이 아사함
    - 또한 가운데는 두 번 방문하지만 바깥쪽은 한 번 방문하는 공평성의 문제가 남아있음



- 총거리 계산

  | 이동      | 8    | 4    | 2    | 5    | 트랙 앞 | 3    | 7    | 9    | 6    | 총계 |
  | --------- | ---- | ---- | ---- | ---- | ------- | ---- | ---- | ---- | ---- | ---- |
  | 현재 위치 | 15   | 14   | 11   | 8    | 3       | 0    | 17   | 19   | 20   |      |
  | 거리      | 1    | 3    | 3    | 5    | 3       | 17   | 2    | 1    | 3    | 38   |

  

### 5. C-SCAN 디스크 스케줄링

- **C-SCAN**
  - SCAN의 공평성 문제를 해결한 기법으로, 헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙을 서비스하고 반대 방향으로 돌아올 때는 서비스하지 않고 이동만 함
  - 공평하게 서비스 받으나 작업 없이 헤드를 이동하는 것을 비효율적
  - 또한 동일한 트랙이 연속적으로 요청이 발생하면 SCAN과 마찬가지로 바깥쪽 트랙이 아사 현상을 겪음
    - 따라서 잘 사용되지 않음



- 총거리 계산

  | 이동      | 8    | 4    | 2    | 5    | 트랙 앞 | 트랙 끝 | 6    | 9    | 7    | 3    | 총계 |
  | --------- | ---- | ---- | ---- | ---- | ------- | ------- | ---- | ---- | ---- | ---- | ---- |
  | 현재 위치 | 15   | 14   | 11   | 8    | 3       | 0       | 24   | 23   | 20   | 19   |      |
  | 거리      | 1    | 3    | 3    | 5    | 3       | 24      | 1    | 3    | 1    | 2    | 46   |

  

### 6. LOOK 디스크 스케줄링

- **LOOK**
  - SCAN의 불필요 부분을 제거하여 효율을 높인 기법으로, 해당 방향에 더 이상 서비스할 트랙이 없으면 방향을 바꿈
  - SCAN보다 성능이 좋으므로 많이 사용됨



- 총거리 계산

  | 이동      | 8    | 4    | 2    | 5    | 3    | 7    | 9    | 6    | 총계 |
  | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 현재 위치 | 15   | 14   | 11   | 8    | 3    | 17   | 19   | 20   |      |
  | 거리      | 1    | 3    | 3    | 5    | 17   | 2    | 1    | 3    | 35   |



### 7. C-LOOK 디스크 스케줄링

- **C-LOOK**
  - C-SCAN의 LOOK 버전으로 해당 방향에 더 이상 서비스할 트랙이 없으면 방향을 바꿈



- 총거리 계산

  | 이동      | 8    | 4    | 2    | 5    | 트랙 끝 | 6    | 9    | 7    | 3    | 총계 |
  | --------- | ---- | ---- | ---- | ---- | ------- | ---- | ---- | ---- | ---- | ---- |
  | 현재 위치 | 15   | 14   | 11   | 8    | 3       | 24   | 23   | 20   | 19   |      |
  | 거리      | 1    | 3    | 3    | 5    | 20      | 1    | 3    | 1    | 2    | 38   |



### 8. SLTF 디스크 스케줄링

- **SLTF**
  - 드럼을 사용하는 일부 하드디스크의 경우 헤드 저지대를 고정하고, 모든 트랙을 읽을 수 있는 여러 개의 헤드를 지지대에 부착
    - 헤드를 움직이는 탐색 시간이 없어서 매우 빠르게 데이터를 주고받을 수 있음
    - 보통 헤드가 고정된 저장장치에 적용되는 SLTF는 매우 고가라 잘 사용되지 않음



## 4. RAID

### 1. RAID의 개요

- **RAID**
  - 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템
    - 동일한 규격의 디스크를 여러 개 모아 구성하며, 장애가 발생했을 때 데이터를 복구하는 데 사용
  - **미러링**
    - 하나의 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고, 하나의 디스크가 고장 났을 때 다른 디스크를 사용하여 데이터를 복구하는 것
    - 이 방식은 2개의 디스크에 거출처럼 똑같은 내용을 저장한다는 의미에서 **미러링**이라 함(RAID 1)
  - **스트라이핑**
    - 데이터를 여러 조각으로 나누어 저장하는 방식
    - 예를 들어 A, B, C, D라는 데이터가 있을 때, 디스크가 하나라면 4번 작업해야 하지만 디스크가 4개일때는 각각의 디스크에 1개씩 저장하여 속도를 높일 수 있음(RAID 0)
    - RAID 0에는 데이터를 복구하는 기능이 없음
      - RAID 10(RAID 1+0)은 미러링 + 스트라이핑을 모두 지원



### 2. RAID 0(스트라이핑)

- **RAID 0**
  - 여러 개의 디스크에 데이터를 여러 갈래로 찢어 저장
    - 예를 들어 4개의 데이터를 4개의 디스크에 저장(이론적으로 일반 시스템보다 4배 빠름)
  - 복구하는 기능은 없기 때문에 장애가 발생하면 데이터를 잃어버림
    - 그러나 입출력이 빨라서 많이 사용됨



### 3. RAID 1(미러링)

- **RAID 1**
  - 하나의 데이터를 2개의 디스크에 나누어 저장하여 장애 시 백업 디스크로 활용
  - 같은 크기의 디스크를 최소 2개 이상 필요하며 짝수 개의 디스크로 구성됨



### 4. RAID 2

- **RAID 2**
  - 오류를 검출하는 기능이 없는 디스크에 대해 **오류 교정 코드**(**ECC**)를 따로 관리하고, 오류가 발생하면 이 코드를 이용하여 복구
    - **오류 검출 코드**: 오류가 발생했는지 확인할 수 있는 코드(대표적으로 **패리티 비트**)
    - **오류 교정 코드**: 오류가 발생했는지 확인하는 동시에 교정할 수 있는 코드(대표적으로 **허밍 코드**)
  - 일반적인 하드디스크에서는 오류 검출 코드가 없고, 메모리의 경우 패리티 비트로 오류 발생 사실은 알 수 있지만 바로 잡을 수 없음
    - 반면 RAID 2는 허밍 코드와 같은 오류 교정 코드를 별도의 디스크에 저장하고 있다가 장애가 발생하면 이를 이용하여 데이터를 복구하는 것
  - RAID 2는 n개의 디스크에 대해 오류 교정 코드를 저장하기 위한 n-1개의 추가 디스크를 필요로 함
    - RAID 1보다 작은 저장 공간을 요구하나 오류 교정 코드를 계산하는 데 많은 시간을 소비하여 잘 사용하지 않음



### 5. RAID 3

- **RAID 3**
  - 패리트 비트를 사용하여 데이터를 복구
    - 패리트 비트에는 짝수 패리트 비트와 홀수 패리트 비트가 존재
      - 짝수 패리트 비트는 1의 총수를 짝수개로, 홀수 패리트 비트는 1의 총수를 홀수개로 만드는 것
    - 한 디스크에 장애가 발생했다면 짝수 패리티 비트와 나머지 디스크의 1의 개수를 근거로 해당 디스크의 값을 알 수 있음
  - **N-way 패리트 비트 방식**
    - 일반적으로 디스크는 섹터 단위로 읽기 때문에 어떤 섹터에 오류가 있는지 없는지 알 수 있음
    - 따라서 오류 검출에 사용하는 패리트 비트를 여러 섹터끼리 묶어서 구성하면 오류가 없는 섹터를 이용하여 오류가 있는 섹터를 복구할 수 있음
  - 즉 RAID 3는 N-way 패리트 비트를 구성한 후 데이터 디스크가 아닌 별도의 디스크에 보관하여 장애 발생 시 오류를 복구함
    - 일반적으로 오류 검출 코드의 크기가 오류 정정 코드보다 작기 때문에 RAID 3에서 추가되는 디스크 양은 4개의 디스크당 1개 정도
    - 그러나 N-way 패리티 비트를 구성하는 데 필요한 계산량이 많다는 것이 단점



### 6. RAID 4

- **RAID 4**
  - RAID 3와 같은 방식이지만 처리하는 데이터가 블록 단위
    - RAID 3에서는 데이터를 모든 디스크의 섹터에 나누어 저장하여 패리트 비트를 구현
      - 이 경우 데이터를 읽거나 쓸 때 패리티 비트를 구성하기 위해 모든 디스크가 동시에 작동해야 함
    - RAID 4에서는 데이터를 하나의 디스크에 블록 단위로 저장하고 패리티 비트를 블록과 연결하여 구성
      - 따라서 데이터가 저장되는 디스크와 패리티 비트가 저장되는 디스크만 동작하는 것이 장점



### 7. RAID 5

- **RAID 5**
  - RAID 4와 같은 방법을 사용하지만 병목 현상을 해결한 것(즉 패리트 비트를 여러 디스크에 분산함)
    - RAID 4는 한 디스크에 모든 패리티 비트를 저장하므로 병목 현상이 발생함
    - 또한 패리티 비트를 저장한 디스크와 다른 디스크가 고장나면 복구가 안됨
  - RAID 5에서는 패리티 비트를 해당 데이터가 없는 디스크에 보관함



### 8. RAID 6

- **RAID 6**
  - RAID 5와 같은 방식이지만 패리티 비트가 2개
    - RAID 5는 디스크 2개가 동시에 장애가 발생하면 복구가 불가능함
    - RAID 6는 이러한 문제를 해결하기 위함
  - 다만 RAID 5보다 계산량이 많고, 4개의 디스크당 2개의 추가 디스크가 필요함



### 9. RAID 10

- **RAID 10**
  - RAID 1(미러링)과 RAID 0(스트라이핑)의 장점을 결합한 형태
  - RAID 01과 RAID 10
    - RAID 01의 경우 4개의 디스크를 2개씩 묶어 RAID 0을 구성하고, RAID 0으로 묶인 디스크를 RAID 1로 다시 묶음
    - RAID 10에서는 4개의 디스크를 2개씩 묶어 RAID 1로 구성하고, RAID 1로 묶인 디스크를 RAID0으로 다시 묶음
    - 둘의 차이점은 RAID 01은 장애 발생 시 복구하기 위해 모든 디스크를 동시에 중단해야 함
      - 하지만 RAID 10은 일부 디스크만 중단하여 복구(따라서 RAID 10을 사용함)



### 10. RAID 50과 RAID 60

- **RAID 50**과 **RAID 60**
  - RAID 10과 마찬가지로 RAID를 0으로 묶어 성능을 높인 방식
  - RAID 60에서 두 번째 패리트 비트를 빼면 RAID 50이 됨
  - RAID 10, RAID 50, RAID 60의 장단점은 1, 5, 6과 동일함



## 5. [심화학습] 하드웨어의 규격과 발전

### 1. 포트의 규격

#### 1.1 메인보드의 포트

- 메인보드의 포트
  - **CPU 포트**
  - **램 포트**
  - **그래픽 포트**: 대용량의 데이터를 전송해야 하므로 CPU와 직접 연결
  - **SATA**: 하드디스크 같은 저장장치를 연결하는 직렬 ATA 포트
  - **PCI**: 그외의 주변장치는 메인보드에 주변장치를 연결하는 PCI 버스 인터페이스에 연결됨



#### 1.2 직렬 포트와 병렬 포트

- 버스 통신 방식
  - **직렬 방식**
    - 데이터가 한 줄로 이동
    - 무조건 느린 것이 아님(SATA와 같은 빠른 포트도 개발됨)
  - **병렬 방식**
    - 데이터가 여러 줄로 동시에 이동



#### 1.3 USB 포트

- **USB 포트**: 직렬 포트와 병렬 포트 등 다양한 연결 방식을 대체하기 위해 만든 포트



#### 1.4 포트 연결 단자

- 포트 연결 단자
  - **USB**: USB 메모리나 카메라 등 다양한 주변장치를 연결할 수 있는 범용 포트
  - **SATA**: 컴퓨터 내부에 있는 각종 저장장치를 연결할 때 사용
  - 모니터 연결 단자
    - **D-SUM**: 가장 오래된 모니터 연결 단자(아날로그 데이터를 전송)
    - **DVI**: 디지털 디스플레이 장치의 화질에 최적화된 표준 영상 인터페이스
      - 모니터 표준 단자로 자리 잡고 있음
    - **HDMI**: 비압축 방식의 디지털 비디오/오디오 인터페이스 규격
      - DVI는 사운드 단자를 따로 연결해야 하나 HDMI는 비디오와 오디오 신호를 하나의 단자로 구현
