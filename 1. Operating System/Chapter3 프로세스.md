# Chapter3 프로세스

[[_TOC_]]

- 오늘날의 컴퓨터 시스템들은 메모리에 다수의 프로그램이 적재되어 병행 실행 되는데, 이러한 발전은 다양한 프로그램을 보다 견고하게 제어하고 보다 구획화할 것이 필요
  - 이런 필요가 프로세스의 개념을 낳았고, **프로세스**란 실행 중인 프로그램을 말함(현대 컴퓨팅 시스템에서 작업의 단위)



## 3.1 프로세스 개념

- 모든 CPU 활동들을 어떻게 부를 것인가?
  - 과거
    - 초기 컴퓨터는 **작업**을 실행하는 일괄 처리 시스템
    - 이후 **사용자 프로그램** 또는 **태스크**를 실행하는 시분할 시스템



### 3.1.1 프로세스

- **프로세스**

  - 비공식적으로 프로세스란 실행 중인 프로그램
  - 프로세스의 현재 활동의 상태는 **프로그램 카운터** 값과 프로세서 레지스터의 내용으로 나뉨
  - 프로세스의 메모리 배치는 일반적으로 여러 섹션으로 구분
    - **텍스트 섹션** - 실행 코드
    - **데이터 섹션** - 전역 변수
    - **힙 섹션** - 프로그램 실행 중에 동적으로 할당되는 메모리
    - **스택 섹션** - 함수를 호출할 때 임시 데이터 저장장소(예: 함수 매개변수, 복귀 주소, 지역 변수)
      - 텍스트 및 데이터 섹션의 크기는 고정되기 때문에 실행 시간동안 크기가 변하지 않음
      - 스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있음
        - 스택 섹션
          - 함수가 호출될 때마다 함수 매개변수, 지역 변수, 복귀 주소를 포함하는 **활성화 레코드**가 스택의 푸쉬
          - 함수에서 제어가 되돌아오면 스택에서 **활성화 레코드**가 팝됨
        - 힙 섹션
          - 메모리가 동적으로 할당됨에 따라 힙이 커지고 메모리가 시스템에 반환되면 축소
        - 스택과 힙 섹션이 서로의 **방향으로** 커지더라도 운영체제는 서로 **겹치지** 않도록 해야 함

  

  - 프로그램과 프로세스
    - 프로그램 그 자체는 프로세스가 아님
      - 프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일(**실행 파일**)과 같은 **수동적인** 존재
      - 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인** 존재
    - 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 됨
      - 적재의 방법
        1. 실행 파일을 나타내는 아이콘을 더블 클릭
        2. 명령어 라인상에서 `prog.exe` 또는 `a.out`과 같이 파일이름을 입력하는 방식

  

  - 두 프로세스들이 동일한 프로그램에 연관될 수 있지만, 이들 두 개의 별도의 실행 순서로 간주
    - 즉, 텍스트 섹션이 동등하다 할지라도 데이터, 힙, 스택 섹션은 다를 수 있음
    - 프로세스가 실행되는 과정에서 많은 프로세스를 생성하는 것이 보통

  

  - 프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있음
    - Java의 예
      - 대부분의 상황에서 실행 가능한 Java 프로그램은 Java 가상기계(JVM) 안에서 실행
      - JVM은 적재된 Java 코드를 해석하고 그 코드를 대신하여 원 기계어를 이용하여 행동을 취하는 프로세스로서 프로그램을 실행
        - 예를 들어, 컴파일된 Java 프로그램 Program.class를 실행하기 위해 `java program` 명령어 입력
          - java 명령어는 JVM을 보통의 프로세스처럼 실행시킴
          - JVM은 Java 프로그램 Program을 가상기계 안에서 실행

  

  ### 3.1.2 프로세스 상태

  - **상태**
    - 프로세스는 실행되면서 변화되며, 프로세스의 현재의 활동에 따라서 정의됨
      - **생성(new)**: 프로세스가 생성 중
      - **실행(running)**: 명령들이 실행 중
      - **대기(waiting)**: 프로세스가 어떤 이벤트가 일어나기를 기다림
      - **준비(ready)**: 프로세스가 처리기에 할당되기를 기다림
      - **종료(terminated)**: 프로세스의 실행이 종료
    - 이 이름들은 임의적이며 운영체제마다 변하지만, 이들이 나타내는 상태는 모든 시스템에서 공통적
      - 한 순간에 한 처리기 코어에서는 오직 하나의 프로세스만 실행됨이 중요

    ![image-20210901121550577](Chapter3 프로세스.assets/image-20210901121550577.png)

  

  ### 3.1.3 프로세스 제어 블록

  - **프로세스 제어 블록**(PCB)(혹은 **태스크 제어 블록**)

    - 약간의 회계 데이터와 프로세스를 시작시키거나 다시 시작시키기 위한 모든 데이터를 저장
    - 특정 프로세스와 연관된 여러 정보를 수록함
      - **프로세스 상태**: 상태는 생성, 준비, 실행, 대기, 정지(halted) 등
      - **프로그램 카운터**: 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킴
      - **CPU 레지스터들**: CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가짐
        - 레지스터에는 누산기(accumulator), 인덱스 레지스터, 스택 레지스터, 범용(general-purpose) 레지스터, 상태 코드 정보가 포함
        - 프로그램 카운터와 함께 이 정보는 프로세스가 다시 스케줄될 때 올바르게 실행하도록 하기 위해 인터럽트 발생 시 저장되야 함
      - **CPU 스케줄링 정보**: 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함
      - **메모리 관리 정보**: 이 정보는 운영체제에 의해 사용되는 메모리 시스템에 따라 기준(base) 레지스터, 한계(limit) 레지스터 값, 운영체제가 사용하는 메모리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
      - **회계 정보**: CPU 사용 시간, 경과된 시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
      - **입출력 상태 정보**: 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함

    ![image-20210901122750032](Chapter3 프로세스.assets/image-20210901122750032.png)

  

  ### 3.1.4 스레드

  - 현대 운영체제는 한 프로세스가 다수의 스레드를 가질 수 있도록 허용함
    - 즉, 프로세스가 한 번에 하나 이상의 일을 수행할 수 있게 함
    - 이를 통해 다중 처리기 시스템에서 여러 스레드가 병렬로 실행될 수 있음

  

  ## 3.2 프로그램 스케줄링

  - 다중 프로그램
    - 목적: CPU의 이용을 최대로 하기 위해 항상 어떤 프로세스가 실행되도록 만드는 것
    - 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것
      - 해당 목적을 위해 **프로세스 스케줄러**는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택
      - 한 개의 CPU 코어는 한 번에 한 개만 실행 가능하므로 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 대기해야 함
        - **다중 프로그래밍 정도**: 현재 메모리에 있는 프로세스 수

  

  - 다중 프로그래밍과 시간 공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야 함
    - 일반적으로 대부분의 프로세스는 I/O 바운드, CPU 바운드
      - **I/O바운드 프로세스**: 계산보다 I/O에 더 많은 시간을 소비하는 프로세스
      - **CPU 바운드 프로세스**: 계산에 더 많은 시간을 사용하여 I/O 요청을 자주 생성하지 않는 프로세스

  

  ### 3.2.1 스케줄링 큐

  - 프로세스가 시스템에 들어가면
    - **준비 큐**에 들어가 준비 상태가 되어 CPU 코어에서 실행을 기다림
      - 해당 큐는 일반적으로 연결 리스트로 저장
    - 준비 큐는 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함

  

  - 프로세스가 CPU 코어에 할당되면

    - 프로세스는 잠시 실행되어 종료 또는 인터럽트되거나 I/O 요청의 완료와 같은 특정 이벤트가 발생할 때까지 기다림
      - I/O 완료와 같이 특정 이벤트가 발생하기를 기다리는 프로세스는 **대기 큐**에 삽입됨

    ![image-20210901135428977](Chapter3 프로세스.assets/image-20210901135428977.png)

    ![image-20210901135906900](Chapter3 프로세스.assets/image-20210901135906900.png)

    - 프로세스 스케줄링의 일반적인 표현은 그림 3.5와 같은 **큐잉 다이어그램**

      - 빨간 원 => 서비스를 제공하는 자원, 화살표 => 시스템 프로세스의 흐름

    - 절차

      - 새 프로세스는 처음에 준비 큐(ready queue)에 놓임

        - 프로세스는 실행을 위해 선택되거나 **디스패치**될 때까지 기다림

      - CPU에 놓여 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있음

        1. 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있음

        2. 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있음

        3. 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있음

        - 처음 2개는 결국 대기 상태에서 준비 상태로 전환된 다음 준비 큐에 다시 들어감
          - 프로세스는 종료까지 이 주기를 계속하고, 종료되면 모든 큐에서 제거되고 PCB와 자원이 반환됨

  ​	

  ### 3.2.3 CPU 스케줄링

  - **CPU 스케줄러**
    - 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당
    - CPU를 할당하기 위해 새 프로세스를 자주 선택해야 함
      - I/O 바운드 프로세스는 I/O 요청을 대기하기 전 몇 밀리초 동안만 실행할 수 있음
      - CPU 바운드 프로세스는 오랜 시간 동안 CPU 코어가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없음
        - 대신 프로세스에서 CPU를 강제로 제거하고 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높음
      - 따라서 CPU 스케줄러는 적어도 100밀리초마다 한 번씩 실행(일반적으로는 더 많이 실행)
    - **스와핑**
      - 때때로 메모리에서 프로세스를 제거하여 다중 프로그래밍 정도를 감소시키는 것
        - 프로세스를 메모리에서 디스크로 "스왑아웃"하고 현재 상태를 저장하고, 이후 디스크에서 메모리로 "스왑인"하여 상태를 복구함
      - 일반적으로 메모리가 초과 사용되어 가용 공간을 확보해야 할 때 필요

  

  ### 3.2.3 문맥 교환

  - 인터럽트 발생 시
    - 시스템은 인터럽트 처리가 끝난 후 **문맥**을 복구할 수 있도록 현재 실행 중인 프로세스를 현재 문맥에 저장할 필요가 있음(결국 프로세스를 중단 후 다시 실행하는 작업)
      - 문맥은 프로세스의 PCB에 표현됨
        - CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등이 포함

  

  - **문맥 교환**

    - 사용자 모드이건  커널 모드이건 CPU의 현재 상태를 저장하는 **작업을 수행** 후 연산 재개를 위해 상태 **복구 작업을 수행**하는 작업
    - 문맥 교환이 일어나면 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구함
      - 문맥 교환 시간은 다른 작업을 못하므로 순수 오버헤드임
        - 문맥 교환 시간은 하드웨어 지원의 큰 영향
          - 예를 들어, 일부 처리기들은 여러 개의 레지스터 집합을 제공함
          - 문맥 교환은 레지스터 집합에 대한 포인터 변경을 해야하고, 레지스터 집합보다 프로세스가 더 많다면, 레지스터 자료를 메모리로 또는 메모리에서 복사해야 함
          - 또한, 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아짐
        - 복잡한 고급 메모리 관리 기법을 사용하면 문맥 교환 시 더 많은 자료를 교환해야 함
          - 예를 들어, 문맥 교환 시 현재 프로세스의 주소 공간은 다음 태스크의 공간이 사용 준비되는 동안 반드시 보존되야 함
          - 주소 공간이 어떤 식으로 보존되고, 보존하기 위해 수행해야 할 작업의 양은 운영체제 메모리 관리 기법에 따라 달라짐

    ![image-20210901161832452](Chapter3 프로세스.assets/image-20210901161832452.png)

  

  - 모바일 시스템에서의 다중 태스킹
    - **전경**에 있는 응용은 화면에 보이면서 실행중인 응용
    - **백그라운드 응용**은 메모리에 남아 있지만, 화면에는 보이지 않는 응용
    - **화면 분할**은 더 큰 모바일 화면을 통해 동시에 2개의 전경 응용을 실행시키는 것

  

  ## 3.3 프로세스에 대한 연산

  - 대부분 시스템은 프로세스들을 병행 실행할 수 있으며, 반드시 동적으로 생성되고 제거되어야 함
    - 즉, 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 함

  

  ### 3.3.1 프로세스 생성

  - 프로세스는 실행하는 동안 여러 프로세스를 생성 가능
    - 생성하는 프로세스를 부모 프로세스, 생성된 프로세스를 자식 프로세스라고 함
    - 결과적으로 **트리**를 형성

  

  - UNIX, Linux, Windows에서의 **프로세스 식별자(pid)**

    - 식별자는 보통 정수이며, 각 프로세스의 고유한 값으로 할당
    - 식별자를 통해 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 index로 사용

    ![image-20210901162512078](Chapter3 프로세스.assets/image-20210901162512078.png)
    - 언제나 pid가 1인 `systemd` 프로세스가 모든 사용자 프로세스의 푸트 부모 프로세스의 역할
      - 시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스로 부팅 후 다양한 사용자 프로세스를 생성
        - 웹 또는 프린트 서버, ssh 서버 등
    - `logind` 프로세스는 시스템에 직접 로그인하는 클라이언트를 관리하는 책임
      - 그림에서는 bash 셸을 사용하여 logind 이후 bash를 실행
        - 이후 사용자가 명령어 라인 인터페이스를 통해 ps 프로세스와 vim 편집기 프로세스를 생성함
    - `sshd` 프로세스는 ssh(secure shell의 축약)을 사용하여 시스템에 접속하는 클라이언트의 관리를 책임

  

  - `ps -el`
    - UNIX와 Linux 시스템에서는 ps 명령어를 사용하여 프로세스 목록을 얻을 수 있음
    - 단, 현재 활성화되어 있는 모든 프로세스의 정보를 나열함
      - 프로세스들의 부모 프로세스가 `systemd`가 나올때까지 재귀적으로 추적

  

- 자식 프로세스가 생성될 때

  - 자원은?

    - 이 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분 집합만으로 제한될 수 있음
      - 후자는 자식을 많이 생성하여 시스템을 과부화시키는 것을 방지할 수 있음

  - 데이터는?

    - 자식이 생성될 때, 초기 데이터(입력)을 전달할 수 있음
      - 예를 들어 입출력 장치에 대한 정보 등

  - 실행 방법은?

    1. 부모는 자식과 병행하게 실행을 계속
    2. 부모는 일부 또는 자식이 종료될 때까지 대기

  - 주소 공간 측면은?

    1. 자식 프로세스는 부모 프로세스의 복사본(자식은 부모와 똑같은 프로그램과 데이터를 가짐)
    2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가짐

    - UNIX에서

      1. fork() 시스템 콜로 프로세스 생성 후 명령어에서부터 실행을 계속
         - 자식은 원래 부모의 주소 공간의 복사본으로 저장됨
         - 이는 부모와 통신을 쉽게 할 수 있게 함

      2. 두 프로세스 중 한 프로세스가 exec() 시스템 콜을 사용하여 자신의 메모리 공간의 새로운 프로그램으로 교체
         - 이진 파일을 메모리로 적재(load)하고 그 프로그램의 실행을 시작함
         - 이 방법으로 두 프로세스는 통신을 할 수 있고, 각자의 길을 감
         - exec()는 프로세스의 주소 공간을 새 프로그램에 덮어쓰므로 오류 발생이 아닌 이상 제어를 반환하지 않음

      3. 이후 부모는 더 많은 자식을 생성하거나, 자식이 끝날 때까지 기다리는 경우 wait() 시스템 콜을 함

      4. 자식은 열린 파일의 자원 외에도 특권과 스케줄링 속성을 상속받고, execlp() 시스템 콜을 사용하여 자신의 주소 공간을 UNIX 명령 /bin/ls로 덮어씀

      5. 자식이 끝나면 부모는 wait() 호출로부터 재개하여, exit() 시스템 콜을 사용해 끝냄

    ![image-20210901190950875](Chapter3 프로세스.assets/image-20210901190950875.png)

    ```c
    #include <sys/types.h>
    #include <stdio.h>
    #include <unistd.h>
    
    int main() {
        pid t pid;
    
        /* 새 프로세스를 생성(fork) */
        pid = fork();
        
        if (pid < 0) { /* 오류 발생 */
        fprintf(stderr, "Fork Failed");
        return 1;
        }
        else if (pid == 0) { /* 자식 프로세스 */
        execlp("/bin/ls","ls",NULL);
        }
        else { /* 부모 프로세스 */
        /* 부모가 자식이 완료되기를 기다릴 것임 */
        wait(NULL);
        printf("Child Complete");
        }
        
    	return 0;
    }
    ```

    - Windows에서

      - Windiws API의 CreateProcess() 함수로 새로운 프로세스 생성
        - fork()와는 달리 같은 주소 공간이 아닌 주소 공간에 명시된 프로그램을 적재하며, 10개 이상의 매개변수를 요구(fork는 요구 X)

      ```c
      #include <stdio.h>
      #include <windows.h>
      
      int main(VOID) {
          STARTUPINFO si;
          PROCESS INFORMATION pi;
          
          
          /* 메모리 할당 */
          ZeroMemory(&si, sizeof(si));
          si.cb = sizeof(si);
          ZeroMemory(&pi, sizeof(pi));
          
          /* 자식 프로세스 생성 */
          if (!CreateProcess(NULL, /* 명령어 라인 사용 */
          "C:∖∖WINDOWS∖∖system32∖∖mspaint.exe", /* 명령어 라인 */
          NULL, /* 프로세스는 상속하지 말 것 */
          NULL, /* 스레드 핸들러 상속하지 말 것 */
          FALSE, /* 핸들 상속 디제이블 */
          0, /* 생성 플래그 없음 */
          NULL, /* 부모 환경 블록 사용 */
          NULL, /* 부모 프로세스가 존재하는 디렉터리 사용 */
          &si,
          &pi))
          {
          fprintf(stderr, "Create Process Failed");
          return -1;
          }
          
          /* 부모 프로세스가 자식 프로세스가 끝나기를 기다림 */
          WaitForSingleObject(pi.hProcess, INFINITE);
          printf("Child Complete");
          
          /* 핸들 닫기 */
          CloseHandle(pi.hProcess);
          CloseHandle(pi.hThread);
      }
      ```

      

      - CreateProcess() 함수에 전달된 두 개의 매개변수는 STARTUPINFO와 PROCESS_INFORMATION 구조체의 인스턴스
        - STARTUPINFO는 윈도 크기와 모양 표준 입력과 출력 파일에 대한 핸들과 같은 새로운 프로세스의 특성을 지정
        - PROCESS_INFORMATION 구조체는 새로 생덩된 프로세스와 스레드에 대한 핸들과 식별자들을 포함
      - ZeroMemory() 함수는 프로세스 생성 함수 전에 각각의 구조체가 쓸 메모리를 할당하기 위함



### 3.3.2 프로세스 종료

- 일반적인 프로세스 종료
  - 마지막 문장의 실행을 끝내고 exit 시스템 콜을 이용하여 운영체제에 자신의 삭제를 요청하면 종료함
    - 이 시점에 자신을 기다리고 있는 부모에(wait를 통해) 상태 값을 반환할 수 있음
    - 물리 메모리, 가상 메모리, 열린 파일, 입출력 버퍼 등 모든 자원이 할당 해제되고 운영체제로 반납



- 종료가 발생하는 다른 경우
  - 한 프로세는 적당한 시스템 콜(Windows의 TerminateProcess() 등)을 통해 다른 프로세스의 종료를 유발할 수 있음
    - 통상적으로, 종료될 프로세스의 부모만이 호출(자식을 생성할 때 자식의 pid는 부모에 전달됨)
      1. 자식이 자신에게 할당된 자원을 초과하여 사용할 경우
      2. 자식에게 할당된 태스크가 더 이상 필요 없는 경우
      3. 부모가 exit를 하는데, 운영체제는 부모가 exit 한 후에 자식이 계속 실행하는 것을 용납하지 않는 경우
         - 이런 경우를 **연쇄식 종료**라 부르며, 운영체제가 수행



- **좀비** 프로세스
  - 자식이 끝났지만, 부모가 wait()를 호출하지 않은 프로세스를 의미



- **고아** 프로세스
  - 자식이 끝났지만, 부모가 wait()가 아닌 exit()로 종료한 경우 생성됨
  - UNIX는 고아 프로세스의 새로운 부모 프로세스로 init 프로세스를 지정하여 해결함
    - init 프로세스는 주기적으로 wait()를 호출하여 고아 프로세스의 종료 상태를 수집하고 프로세스 식별자와 프로세스 테이블 항목을 반환함



#### 3.3.2.1 Android 프로세스 계층

- 모바일의 경우 자원 제약으로 시스템 자원의 회수를 위해 기존 프로세스를 종료해야 하는 경우
  - Android는 임의의 프로세스를 종료하는 것이 아닌 프로세스의 **중요도 계층**을 식별하여 낮은 중요도의 프로세스부터 종료함
    - **전경 프로세스** - 사용자가 현재 상호 작용하고 있는 응용 프로그램(현재 화면에 보이는 프로세스)
    - **가시적 프로세스** - 전경에서 직접 볼 수 없지만 전경 프로세스가 참조하는 프로세스(전경 프로세스에 표시되는 활동을 수행)
    - **서비스 프로세스** - 백그라운드 프로세스와 유사하지만 사용자가 인지할 수 있는 프로세스(ex) 스트리밍)
    - **백그라운드 프로세스** - 활동을 수행하고 있지만 사용자가 인식 못하는 프로세스
    - **빈 프로세스** - 응용 프로그램과 관련된 활성 구성요소가 없는 프로세스
  - 자원을 회수해야 하는 경우 먼저 빈 프로세스를 종료한 다음 백그라운드 프로세스 등의 순서로 종료함
  - 위의 순서는 중복해서 매겨 더 상세한 중요도를 매길 수 있음(ex) 가시적이면서 서비스 프로세스)



## 3.4 프로세스 간 통신

- 영향에 따른 프로세스 분류
  - **독립적** - 시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않는 프로세스
  - **협력적** - 시스템에서 실행 중인 다른 프로세스들에 영향을 주거나 받는 프로세스



- 협력을 허용하는 환경을 제공하는 이유
  1. **정보 공유**: 여러 응용 프로그램이 동일한 정보(ex) 복붙)에 흥미를 느낄 수 있으므로, 그러한 정보를 병행적으로 접근할 환경을 제공해야 함
  2. **계산 가속화**: 태스크를 빨리 수행하기 위해 서브 태스크로 나누고 이들 가각이 다른 서브태스크들과 병렬로 실행하게 해야 함(단, 복수 개의 코어인 경우만)
  3. **모듈성**: 시스템 기능을 별도의 프로세스들 또는 스레드들로 나누어, 모듈식 형태로 시스템을 구성하기를 원하는 경우



- **프로세스 간 통신(IPC)** 기법

  - 협력적 프로세스이 데이터를 교환할 수 있게 만드는 방법
  - 기본적인 방법들(통상 둘 다 운영체제에 구현됨)
    1. **공유 메모리**
       - 협력 프로세스들에 의해 공유되는 메모리 영역이 구축되고, 해당 영역에서 데이터를 읽고 쓰며 정보를 교환할 수 있음
       - 메시지 전달보다 더 빠른 속도를 보임
         - 시스템 콜을 사용하여 구현된 메시지 전달은 커널 간섭 등 부가적 시간 소비 작업이 필요함
    2. **메시지 전달**
       - 메시지를 협력 프로세스들 사이에 교환하여 통신
       - 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터 교환에 유리하며 구현이 쉬움

  ![image-20210901200526987](Chapter3 프로세스.assets/image-20210901200526987.png)



## 3.5 공유 메모리 시스템에서의 프로세스 간 통신

- 공유 메모리 방식은 통신하는 프로세스들이 공유 메모리 영역을 구축해야 함
  - 보통 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간 안에 위치
  - 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 함
  - 운영체제는 한 프로세스가 다른 프로세스의 메모리 접근을 금지함
    - 즉, 공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로 함
    - 동의 이후에 공유 영역에 일고 쓰면서 정보를 교환할 수 있음
  - 데이터의 형식과 위치는 이들 프로세스에 의해 결정되며 운영체제 소관이 아님
    - 또한, 프로세스들은 동시에 동일한 위치에 쓰지 않도록 책임져야 함



- **버퍼**

  - 생산자와 소비자 프로세스들이 병행으로 실행되려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 버퍼가 반드시 사용 가능해야 함

    - 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재
    - 생산자와 소비자는 반드시 동기화되어야 함을 의미

  - 버퍼의 유형

    - **무한 버퍼**

    - **유한 버퍼**

      - 버퍼의 크기가 고정되어 있다고 가정
        - 즉, 버퍼가 비어있으면 소비자는 반드시 대기해야 하며, 모든 버버파 채워져 있으면 생산자가 대기함

      ```c
      #define BUFFER SIZE 10(유한 버퍼 예시)
      
      typedef struct {
      . . .
      } item;
      
      item buffer[BUFFER SIZE];
      int in = 0;
      int out = 0;  # 변수들은 생산자와 소비자 프로세스가 공유하는 메모리 영역에 존재
      ```

      - 공유 버퍼는 두 개의 논리 포인터 in과 out을 갖는 원형 배열로 구현
        - 변수 in은 버퍼 내에서 다음 비어 있는 위치를 가릭키며, out은 버퍼 내에서 첫 번째로 채워져 있는 위치를 가리킴
          - 즉, `in == out`일 때 버퍼는 비어 있고, `((in+1)% BUFFER_SIZE == out)`일 때 버퍼는 가득 차 있음

      ```c
      /* 생산자 프로세스 */
      item next_produced;
      
      while (true) {
      /* produce an item in next produced */
          
          while (((in + 1) % BUFFER SIZE) == out)
          ; /* do nothing */
          
          buffer[in] = next_produced;
          in = (in + 1) % BUFFER_SIZE;
      }
      ```

      ```c
      /* 소비자 프로세스 */
      item next_consumed;
      while (true) {
          while (in == out)
          ; /* do nothing */
          
          next_consumed = buffer[out];
          out = (out + 1) % BUFFER_SIZE;
          
          /* consume the item in next consumed */
      }
      ```

      - 생산자 프로세스는 `next_produced`라는 지역 변수에 다음 번 생성되는 item을 저장
      - 소비자 프로세스는 `next_consumed`라는 지역 변수에 다음 번 소비되는 item을 저장











